<?xml version="1.0" encoding="US-ASCII"?>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com)
     by Daniel M Kohn (private) -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>
<rfc category="std" docName="draft-wwx-netmod-event-yang-10" ipr="trust200902">
  <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <?rfc toc="yes" ?>

  <?rfc symrefs="yes" ?>

  <?rfc sortrefs="yes"?>

  <?rfc iprnotified="no" ?>

  <?rfc strict="yes" ?>

  <front>
    <title abbrev="ECA YANG">A YANG Data model for ECA Policy
    Management</title>

    <author fullname="Andy Bierman" initials="A." surname="Bierman">
      <organization>YumaWorks</organization>

      <address>
        <email>andy@yumaworks.com</email>
      </address>
    </author>

    <author fullname="Qin Wu" initials="Q." surname="Wu">
      <organization>Huawei</organization>

      <address>
        <postal>
          <street>101 Software Avenue, Yuhua District</street>

          <city>Nanjing</city>

          <region>Jiangsu</region>

          <code>210012</code>

          <country>China</country>
        </postal>

        <email>bill.wu@huawei.com</email>
      </address>
    </author>

    <author fullname="Igor Bryskin" initials="I." surname="Bryskin">
      <organization>Individual</organization>

      <address>
        <email>i_bryskin@yahoo.com</email>
      </address>
    </author>

    <author fullname="Henk Birkholz" initials="H." surname="Birkholz">
      <organization>Fraunhofer SIT</organization>

      <address>
        <email>henk.birkholz@sit.fraunhofer.de</email>
      </address>
    </author>

    <author fullname="Xufeng Liu" initials="X." surname="Liu">
      <organization>Volta Networks</organization>

      <address>
        <email>xufeng.liu.ietf@gmail.com</email>
      </address>
    </author>

    <author fullname="Benoit Claise" initials="B." surname="Claise">
      <organization>Cisco</organization>

      <address>
        <email>bclaise@cisco.com</email>
      </address>
    </author>

    <author fullname="Alexander L Clemm" initials="A." surname="Clemm">
      <organization>Futurewei</organization>

      <address>
        <email>ludwig@clemm.org</email>
      </address>
    </author>

    <date year="2020"/>

    <area>OPS Area</area>

    <workgroup>NETMOD Working Group</workgroup>

    <keyword>RFC</keyword>

    <keyword>Request for Comments</keyword>

    <keyword>I-D</keyword>

    <keyword>Internet-Draft</keyword>

    <keyword>Event Condition Action YANG</keyword>

    <abstract>
      <t>This document defines a YANG data model for Event Condition Action
      (ECA) policy management. The ECA policy YANG module provides the ability
      to delegate some network management functions to the server which can
      take simple and instant action when a trigger condition on the system
      state is met.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t>Traditional approaches for network to automatically perform
      corrective actions in response to network events have been largely built
      on centralized policy based management [RFC3198]. With centralized
      network mangement, the managed object state or operational state
      spanning across the devices needs to be retrieved by the client from
      various different servers. However there are issues associated with
      centrallized network management:<list style="symbols">
          <t>Centralized network management incurs massive data collection and
          processing, the resource consumption (e.g., network bandwidth usage,
          the state to be maintained) is huge;</t>

          <t>Centralized network management leads to slow reaction to the
          network changes when large amounts of managed object state from
          devices needs to collected and correlated at the central point where
          decisions about resource adjustment are made;</t>

          <t>Centralized network management cannot control or influence
          management behavior within the server if the server is not connected
          to any network or the existing configuration on the server has major
          errors;</t>

          <t>Centralized network management doesn't scale well when thousands
          of devices needs to send hundreds of event notifications, or
          millions of managed data objects needs to be polled by the
          client;</t>
        </list></t>

      <t>A more effective alternative to centralized network management is to
      delegate network management functions to servers in the network and
      allow each server to monitor state changes of managed objects.
      Accordingly there is a need for a service to provide continuous
      peformance monitoring, detect defects and failures, and take corrective
      action.</t>

      <t>This document defines an ECA Policy management YANG data model. The
      ECA Policy YANG allows the client to move the network management task to
      the server, which provides the ability to control the configurations and
      monitor state parameters, and take simple and instant action on the
      server when a trigger condition on the system state is met.</t>

      <t>The data model in this document is designed to be compliant with the
      Network Management Datastore Architecture (NMDA) [RFC8342].</t>
    </section>

    <section title="Conventions used in this document">
      <section title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in [RFC2119]. In this
        document, these words will appear with that interpretation only when
        in ALL CAPS. Lower case uses of these words are not to be interpreted
        as carrying [RFC2119] significance.</t>

        <t>The following terms are defined in [RFC7950] [RFC3178] and are not
        redefined here: <list style="symbols">
            <t>Policy Decision Point (PDP)</t>

            <t>Policy Enforcement Point (PEP)</t>

            <t>Provisioned Policy</t>

            <t>Server</t>

            <t>Client</t>

            <t>Event</t>
          </list></t>

        <t>This document uses the following terms: <list style="hanging">
            <t hangText="Condition:">Condition can be seen as a logical test
            that, if satisfied or evaluated to be true, causes the action to
            be carried out.<vspace blankLines="1"/></t>

            <t hangText="Action:">Update or invocation on local managed object
            attributes.</t>

            <t hangText="ECA Event:">The input to the ECA logic that initiates
            the processing derived from an extensible list of platform event
            types.</t>

            <t hangText="Server Event:">An event that happens in the server
            for which a Notification could be generated in an Event Stream
            subscription.</t>

            <t hangText="Datastore Event:">An event that happens within a
            datastore within the server for which a Notification could be
            generated in a datastore subscription.</t>

            <t hangText="Timer Event:">A pseudo-event in the server that
            allows ECA logic to be invoked periodically.</t>

            <t hangText="Diagnostic Event:">A pseudo-event initiated by the
            client to test ECA logic.</t>

            <t hangText="Self Monitoring:">Automatic monitoring of resources
            to ensure the optimal functioning with respect to the defined
            requirements.</t>

            <t hangText="Self Healing:">Automatic discovery and correction of
            faults; automatically applying all necessary Actions to bring the
            system back to normal operation.</t>

            <t hangText="Policy Variable (PV):">Represents datastore states
            that change (or "vary"), and that is set or evaluated by
            software.</t>

            <t hangText="PV-Source:">Represents an XPath result, which
            contains one of four data types: Boolean, Number, String, and Node
            Set.</t>

            <t hangText="PV-Result:">Represents the value of the result of an
            Policy Variable evaluation.</t>

            <t/>
          </list></t>
      </section>

      <section title="Tree Diagrams">
        <t>Tree diagrams used in this document follow the notation defined in
        [RFC8340].</t>
      </section>
    </section>

    <section title="Overview of ECA YANG Data Model">
      <t>A ECA policy rule is read as: when event occurs in a situation where
      condition is true, then action is executed. Therefore ECA comprises
      three key elements: event, associated conditions, and actions. These
      three elements should be pushed down and configured on the server by the
      client. If the action is rejected by the server duing ECA policy
      execution, the action should be rolled back and cleaned up.</t>

      <section title="ECA Policy Variable and Value">
        <t>ECA policy variable (PV) generically represents datastore states
        that change (or "vary"), and that is set or evaluated by software. The
        value of ECA policy variable is used for modeling values and constants
        used in policy conditions and actions. In policy, conditions and
        actions can abstract information as "policy variables" to be evaluated
        in logical expressions, or set by actions, e.g., the policy condition
        has the semantics "variable matches value" while policy action has the
        semantics "set variable to value".</t>

        <t>In ECA, two type of policy variables are defined, pv-source
        variable and pv-result variable. pv-source variable represents an
        XPath expression input, which contains one of four data types:
        Boolean, Number, String, and Node Set while pv-result variable
        represents the value of the result of an Policy Variable evaluation.
        <list style="symbols">
            <t>A pv-source is always config = true.</t>

            <t>A pv-result is always config = false.</t>

            <t>A single anydata cannot be used for all values since it is only
            allowed to contain child nodes. Separate scalar and nodeset values
            are needed.</t>
          </list>Each ECA policy variable has the following two
        attributes:<list style="symbols">
            <t>Name with Globally unique or ECA unique scope ;</t>

            <t>Type either pv-source or pv-result;</t>
          </list></t>

        <t>The following operations are allowed with/on a PV: <list
            style="symbols">
            <t>initialize (with a constant/enum/identity);</t>

            <t>set (with contents of another same type PV);</t>

            <t>read (retrieve datastore contents pointed by the specified same
            type XPath/sub-tree);</t>

            <t>write (modify configuration data in the datastore with the PV's
            content/value);</t>

            <t>function calls or RPC in a form of F(arg1,arg2,...), where F is
            an identity of a function from extendable function library,
            arg1,arg2,etc are PVs respectively, the function's input
            parameters, with the result returned in result policy
            variable.</t>
          </list></t>

        <t>PVs could also be a source of information sent to the client in
        notification messages.</t>

        <t>PVs could be also used in condition expressions.</t>

        <t>The model structure for the Policy Variable is shown below: <figure>
            <artwork>     +--rw policy-variables
     |  +--rw policy-variable* [name]
     |     +--rw name                            string
     |     +--rw type                            identityref
     |     +--rw (xpath-value-choice)?
     |        +--:(policy-source)
     |        |  +--rw (pv-source)
     |        |     +--:(xpath-expr)
     |        |     |  +--rw xpath-expr?         yang:xpath1.0
     |        |     +--:(scalar-constant)
     |        |     |  +--rw scalar-constant?    string
     |        |     +--:(nodeset-constant)
     |        |        +--rw nodeset-constant?   &lt;anydata&gt;
     |        +--:(policy-result)
     |           +--rw (pv-result)
     |              +--:(scalar-value)
     |              |  +--rw scalar-value?       string
     |              +--:(nodeset-value)
     |                 +--rw nodeset-value?      &lt;anydata&gt;</artwork>
          </figure></t>
      </section>

      <section title="ECA Event">
        <t>The ECA Event is any subscribable event notification either
        explicitly defined in a YANG module (e.g., interface management model)
        supported by the server or a event stream conveyed to the server via
        YANG Push subscription. The ECA event are used to keep track of state
        of changes associated with one of multiple operational state data
        objects in the network device.</t>

        <t>Each ECA Event can be classified into server event, datastore
        event, timer event, diagnostics event and has the following common
        attributes:<list style="symbols">
            <t>event-name, the name of ECA event;</t>

            <t>event-type, typical examples of ECA event type include server
            event, datastore event, timer event and diagnostic event.</t>
          </list>For server event, the following additional attributes are
        defined:<list style="symbols">
            <t>event-stream,typical example of event stream is NETCONF
            stream.</t>

            <t>event-module, the name of YANG module associated with the ECA
            event.</t>

            <t>event, it is event stream conveyed to the server.</t>
          </list>For datastore event, the following additional attributes are
        defined:<list>
            <t>datastore, the name of the datastore, typical example of
            datastore is running, operational state datastores.</t>

            <t>data-path, in the form of XPATH expression.</t>

            <t>data, it is event notification defined in a YANG module.</t>
          </list></t>

        <t>A client may define an event of interest by making use of YANG PUSH
        subscription. Specifically, the client may configure an ECA event
        according to the ECA model specifying the event's name, as well as the
        name of corresponding PUSH subscription. In this case, the server is
        expected to: <list style="symbols">
            <t>Register the event recording its name and using the referred
            PUSH subsription trigger as definition of the event firing
            trigger;</t>

            <t>Auto-configure the event's ECA input in the form of local PVs
            using the PUSH subscription's filters;</t>

            <t>At the moment of event firing intercept the notifications that
            would be normally sent to the PUSH subscription's client(s); copy
            the data store states pointed by the PUSH subscription's filters
            into the auto-configured ECA's local PVs and execute the ECA's
            condition-action chain.</t>
          </list></t>

        <t>All events (specified in at least one ECA pushed to the server) are
        required to be constantly monitored by the server. One way to think of
        this is that the server subscribes to its own publications with
        respect to all events that are associated with at least one ECA.</t>

        <t>The model structure for the ECA Event is shown below:</t>

        <figure>
          <artwork>     +--rw events
     |  +--rw event* [event-name]
     |     +--rw event-name               string
     |     +--rw event-type?              identityref
     |     +--rw policy-variable*         -&gt; /gncd/policy-variables/policy-variable/name
     |     +--rw local-policy-variable*   -&gt; /gncd/ecas/eca/policy-variable/name
     |     +--rw (type-choice)?
     |        +--:(server-event)
     |        |  +--rw event-stream?      string
     |        |  +--rw event-module?      string
     |        |  +--rw event?             &lt;anydata&gt;
     |        +--:(datastore-event)
     |        |  +--rw datatore?          string
     |        |  +--rw data-path?         string
     |        |  +--rw data?              &lt;anydata&gt;
     |        +--:(timer-event)
     |        +--:(diagnostics-event)</artwork>
        </figure>
      </section>

      <section title="ECA Condition">
        <t>The ECA Condition is the logical expression that is specified in a
        form of Xpath expression and evaluated to TRUE or FALSE. The XPath
        expression specifies an arbitrary logical/mathematical expression; The
        elements of the ECA Condition expression are referred by the XPaths
        pointing to referred datastore states.</t>

        <t>The ECA Condition expression in the form of XPath expression allows
        for specifying a condition of arbitrary complexity as a single string
        with an XPath expression, in which pertinent PVs and datastore states
        are referred to by their respective positions in the YANG tree.</t>

        <t>ECA Conditions are associated with ECA Events and evaluated only
        within event threads triggered by the event detection.</t>

        <t>When an ECA Condition is evaluated to TRUE, the associated ECA
        Action is executed.</t>

        <t>The model structure for the condition is shown below: <figure>
            <artwork>     +--rw conditions
     |  +--rw condition* [name]
     |     +--rw name                     string
     |     +--rw (expression-choice)?
     |        +--:(xpath)
     |           +--rw condition-xpath?   string</artwork>
          </figure></t>

        <section title="Mapping Policy Variables to XPath Variables">
          <t>Policy variables are mapped to XPath variable bindings so they
          can be referenced in the XPath expression for a Condition.<list
              style="symbols">
              <t>The 'name' leaf value for the policy variable is mapped to
              the local-name of the XPath variable. No namespace is used for
              ECA varaibles. Eg., the policy variable named 'foo' would be
              accessible with a variable refernece '$foo'.</t>

              <t>The local-name 'USER' is reserved and defined in NACM. The
              server SHOULD provide the USER variable as NACM is
              implemented.</t>

              <t>XPath variables can be used in 2 main ways in an
              expression:<figure>
                  <artwork>1) anchor of a path-expr

      $node-set-variable/child1/nested2

2) right-hand side of a primary-expr

     /foo[name = $scalar-variable]</artwork>
                </figure></t>

              <t>It cannot be used in the middle of a path-expr<figure>
                  <artwork>/interfaces/$node-set-variable/child1/nested2     // NOT OK</artwork>
                </figure></t>

              <t>Since a variable is a primary expression it can be used in
              XPath expression constructions anywhere a primary-expr is
              allowed<figure>
                  <artwork>   $nodeset-variable1 | $ nodeset-variable2

   ($min-length + $avg-length) &lt; $last-length</artwork>
                </figure></t>

              <t>The values of all available policy variables are updated by
              the server (if required) before the XPath expression is
              evaluated. The variable binding value MUST NOT change while the
              XPath expression is being evaluated. If multiple references to
              the same variable exist in an XPath expression, they MUST
              resolve to the same value in each instance.<figure>
                  <artwork>
Example:  "/test1[name=$badfan] and /test2[name=$badfan]"
     The same value of 'badfan' is expected in each instance.</artwork>
                </figure></t>

              <t>If a variable reference cannot be resolved because no policy
              variable with that name is accessible to the ECA under
              evaluation, then an eca-exception notification SHOULD be
              generated, and the XPath evaluation MUST be terminated with an
              error.</t>
            </list></t>
        </section>

        <section title="ECA XPath Context">
          <t>All XPath expressions used in ECA share the following XPath
          context definition.<list style="symbols">
              <t>The set of namespace declarations is the set of all modules
              loaded into the server at the moment. Prefix bindings can
              reference the set of namespace URIs for this set of modules.</t>

              <t>All names SHOULD be namespace-qualified. There is no default
              namespace to use if no namespace is specified. If no namespace
              is used then the XPath step matches the local-name in all
              namespaces.</t>

              <t>The function library is the core function library defined in
              [XPATH], the functions defined in Section 10 of [RFC7950], and
              the ECALIB functions defined in this document <xref
              target="ecalib"/>.</t>

              <t>The set of variable bindings is set to all policy variables
              that are visible to the ECA under evaluation. This includes the
              local-policy-variable and policy-variable entries configured for
              the 'eca' entry. Since pv-source values can reference other
              policy variables, the order that these fields are set is
              significant.</t>

              <t>The accessible tree is all state data in the server, and the
              running configuration datastore. The root node has all top-level
              data nodes in all modules as children.</t>

              <t>The context node for all ECA XPath evaluation is the root
              node.</t>
            </list></t>
        </section>

        <section title="ECA Evaluation Exceptions">
          <t>Not all errors can be detected at configuration time. Error that
          occur while ECA logis is being evaluated will cause the server to
          generate an eca-exception notification.</t>

          <t>If the ECA is scheduled one time, an exception will cause the ECA
          entry to be disabled automatically. If the ECA is scheduled
          periodically, ECA entry execution will be skip in the current period
          interval and continue in the next period interval.</t>

          <figure>
            <artwork>   identity eca-exception-reason {
     description
       "Base of all values for the 'reason' leaf in the
       eca-exception notification.";
   }

   identity varbind-unknown {
     base eca-exception-reason;
     description
       "The requested policy variable binding is not defined.
        The variable binding cannot be resolved in the XPath
        evaluation.";
   }
   identity func-invoke-error {
     base eca-exception-reason;
     description
       "The function call is invoked and return false output.";
    }
   identity rpc-call-error {
     base eca-exception-reason;
     description
       "The rpc call is invoked and return false output.";
    }

   // Additional exceptions can be added as needed
    notification eca-exception {
      description
        "This notification is sent when some error occurs
         while the server is processing ECA logic.";
       leaf reason {
         type eca-exception-reason;
       }
    }</artwork>
          </figure>
        </section>
      </section>

      <section title="ECA Action">
        <t>The ECA Action list consists of updates or invocations on local
        managed object attributes and a set of actions are defined as follows,
        which will be performed when the corresponding event is
        triggered:<list style="symbols">
            <t>sending one time notification</t>

            <t>(re-)configuration scheduling - scheduling one time or periodic
            (re-)configuration in the future</t>

            <t>stopping current ECA;</t>

            <t>invoking the same ECA recursively;</t>
          </list></t>

        <t>Three points are worth noting:<list style="symbols">
            <t>When a "Send notification" action is configured as an ECA
            Action, the notification message to be sent to the client may
            contain not only elements of the data store (as, for example, YANG
            PUSH or smart filter notifications do), but also the contents of
            global and local PVs, which store results of arbitrary operations
            performed on the data store contents (possibly over arbitrary
            period of time) to determine, for example, history/evolution of
            data store changes, median values, ranges and rates of the
            changes, results of configured function calls and expressions,
            etc. - in short, any data the client may find interesting about
            the associated event with all the logic to compute said data
            delegated to the server. Importantly, ECA notifications are the
            only ECA actions that directly interact with and hence need to be
            unambiguously understood by the client. Furthermore, the same ECA
            may originate numerous single or repetitive semantically different
            notifications within the same or separate event firings. In order
            to facilitate for the client the correlation of events and ECA
            notifications received from the server, the ECA model requires
            each notification to carry mandatory information, such as event
            and (event scope unique) notification names.</t>

            <t>Multiple ECA Actions could be triggered by a single ECA
            event.</t>

            <t>Any given ECA Condition or Action may appear in more than one
            ECAs.</t>
          </list></t>

        <t>The model structure for the actions is shown below: <figure>
            <artwork>     +--rw actions
     |  +--rw time-schedule!
     |  |  +--rw period?   centiseconds
     |  +--rw action* [name]
     |     +--rw name                   string
     |     +--rw action-element* [name]
     |     |  +--rw name                      string
     |     |  +--rw action-type?              identityref
     |     |  +--rw (action-operation)?
     |     |     +--:(action)
     |     |     |  +--rw next-period         boolean
     |     |     |  +--rw action-name?
     |     |     |          -&gt; /gnca/actions/action/name
     |     |     +--:(function-call)
     |     |     |  +--rw function-call
     |     |     |     +--rw func-name       leafref
     |     |     |     +--rw policy-source   leafref
     |     |     |     +--rw policy-result   leafref
     |     |     |  +--:(rpc-operation)
     |     |     |  |  +--rw rpc-operation
     |     |     |  |     +--rw rpc-name?          string
     |     |     |  |     +--rw nc-action-xpath?   string</artwork>
          </figure></t>
      </section>

      <section title="ECA">
        <t>An ECA container includes:<list style="symbols">
            <t>ECA name.</t>

            <t>List of local PVs and global PVs. As mentioned, These PVs could
            be configured as dynamic (their instances appear/disappear with
            start/stop of the ECA execution) or as static (their instances
            exist as long as the ECA is configured). Global PV will be shared
            by multiple ECA instances while local PVs are within the scope of
            a specific ECA instance.</t>

            <t>Normal CONDITION-ACTION list: configured conditions each with
            associated actions to be executed if the condition is evaluated to
            TRUE</t>
          </list></t>

        <t>Note that this document currently focuses on one event with
        multiple conditions and actions case. How different ECAs do not impact
        each other if they share PVs and other components is not in the scope
        of this document at this moment.</t>

        <section anchor="ecalib" title="ECA XPath Function Library (ECALIB)">
          <t>A set of common event PVs need to be set for every invocation of
          condition or action logic:</t>

          <figure>
            <artwork>   $event-type      (string)
   $event-name    (string)

For event-type = "server-event"

  $event-stream   (string)
  $event-module   (string)
  $event-name     (string)
  $event          (node-set)

The condition can use these PVs directly in an expression
An expression can access client-configured PVs of course

   $event/child[name=$some-global-var] &gt; 10

For event-type = "datastore"

  $datastore  (string)
  $data-path  (string)
  $data       (node-set)
 
The data is defined to be a container with the requested data as child nodes

  $data/interface[type=$gigabit-eth] // (node-set is an array of data nodes, usually 
  siblings)

A standard func call should be defined to specify operation on policy variables 
and xpath expression and store func result.
//Increment count by one each time increment-func is invoked
boolean function increment-func(number count)

//Decrement count by one each time decrement-func is invoked
boolean function decrement-func(number count)

//Exit the loop to monitor specific event
boolean function exit-func()

//Continue the loop to monitor the specific event
boolean function continue-func()

//set iteration variable as true if count variable is equal to or greater than 1
//set iteration variable as false if count variable is zero
boolean function match-func (string expr,number count,boolean iteration)  
 
// check every 5 seconds until the same event occurs 2 times
  sustained-event("$event/child[type=$some-global-var]/descendant[$leaf1 &gt; 10]", 5, 2)

boolean function sustained-event (string expr, number interval, number count)
        test expression 'expr' once per 'interval'. Keep testing once per 
        interval until true result reached, i.e., both xpath expression is 
        evaluated to true and 'count' number of interval on specific data 
        object has been tested true 
        (e.g., the same event occurs 'count' times )Return true if condition 
        tested true for count intervals; Returns false otherwise;

// check the event record every 5 seconds and filter the event record with 
   constraint of a specific descendant node to the event record root node
   filtered-event("$event/child/descendant[$leaf1 &gt; 10]", "$event",5)

boolean function filtered-event (string input-expr,string output-expr,number 
        interval)test expression 'expr'once per 'interval' and generate event 
        record output represented by 'output-expr' based on 'input-expr'. 
        Note than 'output-expr'and 'input-expr'share the same root node;   

A standard rpc should be defined to specify the operation on the event stream
// suppress the event stream corresponding to XPATH expression
boolean rpc event-duplication-suppress(string expr)             </artwork>
          </figure>

          <t>The ECA XPath function library is expected to grow over time and
          additional standard or vendor function libraries should be possible.
          The server should provide a read-only list of ECA function libraries
          supported.<figure>
              <artwork>     +--rw eca-func-libs
        +--rw eca-function* [func-name]
        |   +--rw func-name    string
        +--rw eca-rpc* [rpc-name]
        |  +--rw rpc-name     string
        +--rw eca-name    -&gt; /gncd/ecas/eca/name</artwork>
            </figure></t>

          <t>Note that ECA accesses specific datastores in the same way as
          YANG Push [RFC8641]. The difference is condition expression is
          introduced to further filter nodes in the node set and the policy
          variable is introduced to keep the intermediate states during the
          interaction between the local client and the server.</t>
        </section>
      </section>
    </section>

    <section title="ECA YANG Model (Tree Structure)">
      <t>The following tree diagrams [RFC8340] provide an overview of the data
      model for the "ietf-eca" module. <figure>
          <artwork>module: ietf-eca
  +--rw gncd
     +--rw policy-variables
     |  +--rw policy-variable* [name]
     |     +--rw name                            string
     |     +--rw type                            identityref
     |     +--rw (xpath-value-choice)?
     |        +--:(policy-source)
     |        |  +--rw (pv-source)
     |        |     +--:(xpath-expr)
     |        |     |  +--rw xpath-expr?         yang:xpath1.0
     |        |     +--:(scalar-constant)
     |        |     |  +--rw scalar-constant?    string
     |        |     +--:(nodeset-constant)
     |        |        +--rw nodeset-constant?   &lt;anydata&gt;
     |        +--:(policy-result)
     |           +--rw (pv-result)
     |              +--:(scalar-value)
     |              |  +--rw scalar-value?       string
     |              +--:(nodeset-value)
     |                 +--rw nodeset-value?      &lt;anydata&gt;
     +--rw events
     |  +--rw event* [event-name]
     |     +--rw event-name               string
     |     +--rw event-type?              identityref
     |     +--rw policy-variable*         -&gt; /gncd/policy-variables/policy-variable/name
     |     +--rw local-policy-variable*   -&gt; /gncd/ecas/eca/policy-variable/name
     |     +--rw (type-choice)?
     |        +--:(server-event)
     |        |  +--rw event-stream?      string
     |        |  +--rw event-module?      string
     |        |  +--rw event?             &lt;anydata&gt;
     |        +--:(datastore-event)
     |        |  +--rw datatore?          string
     |        |  +--rw data-path?         string
     |        |  +--rw data?              &lt;anydata&gt;
     |        +--:(timer-event)
     |        +--:(diagnostics-event)
     +--rw conditions
     |  +--rw condition* [name]
     |     +--rw name                     string
     |     +--rw (expression-choice)?
     |        +--:(xpath)
     |           +--rw condition-xpath?   string
     +--rw actions
     |  +--rw time-schedule!
     |  |  +--rw period?   centiseconds
     |  +--rw action* [name]
     |     +--rw name              string
     |     +--rw action-element* [name]
     |     |  +--rw name                      string
     |     |  +--rw action-type?              identityref
     |     |  +--rw (action-operation)?
     |     |     +--:(action)
     |     |     |  +--rw next-period         boolean
     |     |     |  +--rw action-name?
     |     |     |          -&gt; /gnca/actions/action/name
     |     |  |  +--:(function-call)
     |     |  |  |  +--rw function-call
     |     |  |  |     +--rw func-name       leafref
     |     |  |  |     +--rw policy-source   leafref
     |     |  |  |     +--rw policy-result   leafref
     |     |  |  +--:(rpc-operation)
     |     |  |  |  +--rw rpc-operation
     |     |  |  |     +--rw rpc-name?          string
     |     |  |  |     +--rw nc-action-xpath?   string
     +--rw ecas
     |  +--rw eca* [name]
     |     +--rw name                string
     |     +--rw username            string
     |     +--rw event-name          string
     |     +--rw policy-variable* [name]
     |     |  +--rw name                            leafref
     |     |  +--rw is-static?                      boolean
     |     +--rw condition-action* [name]
     |     |  +--rw name         string
     |     |  +--rw condition*   -&gt; /gncd/conditions/condition/name
     |     |  +--rw action?      -&gt; /gncd/actions/action/name
     |     +---x start
     |     +---x stop
     |     +---x next-action
     +--rw eca-func-libs
        +--rw eca-function* [func-name]
        |  +--rw func-name    string
        +--rw eca-rpc* [rpc-name]
        |  +--rw rpc-name     string
        +--rw eca-name    -&gt; /gncd/ecas/eca/name

  notifications:
    +---n eca-exception
    |  +--ro reason?   identityref
    +---n custom-notification
       +--ro eventTime       yang:date-and-time
       +--ro event-type?     identityref
       +--ro (type-choice)?
       |   +--:(server-event)
       |   |  +--ro event-stream?      string
       |   |  +--ro event-module?      string
       |   |  +--ro policy-result      leafref
       |   +--:(datastore-event)
       |   |  +--ro datatore?          string
       |   |  +--ro data-path?         string
       |   |  +--ro policy-result      leafref</artwork>
        </figure></t>
    </section>

    <section title="ECA YANG Module">
      <t>&lt;CODE BEGINS&gt; file "ietf-eca@2019-10-28.yang"</t>

      <figure>
        <artwork>module ietf-eca {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-eca";
  prefix gnca;

  import ietf-yang-types {
    prefix yang;
  }
  import ietf-netconf-acm {
   prefix nacm;
   reference
    "RFC8341: Network Configuration Access Control Model";
  }
  organization
    "IETF Network Configuration (NETCONF) Working Group";
  contact
    "WG Web:   &lt;http://tools.ietf.org/wg/netmod/&gt;
     WG List:  &lt;mailto:netmod@ietf.org&gt;
     Editor:   Qin Wu
               &lt;mailto:bill.wu@huawei.com&gt;
     Editor:   Igor Bryskin
               &lt;mailto:Igor.Bryskin@huawei.com&gt;
     Editor:   Henk Birkholz
               &lt;mailto:henk.birkholz@sit.fraunhofer.de&gt;
     Editor:   Xufeng Liu
               &lt;mailto:xufeng.liu.ietf@gmail.com&gt;
     Editor:   Benoit Claise
               &lt;mailto:bclaise@cisco.com&gt;
     Editor:   Andy Bierman
               &lt;mailto:andy@yumaworks.com&gt;
     Editor:   Alexander Clemm
               &lt;mailto:ludwig@clemm.org&gt;";
  description
    "Event Condition Action (ECA) model.";

  revision 2018-06-22 {
    description
      "Initial revision";
    reference
      "RFC XXXX";
  }

  identity argument-type {
    description
      "Possible values are:
       constant, variable, or datastore state.";
  }

  identity comparison-type {
    description
      "Possible values are:
       equal, not-equal, greater, greater-equal, less, less-equal.";
  }

  identity logical-operation-type {
    description
      "Possible values are:
       not, or, and.";
  }

  identity function-type {
    description
      "Possible values are:
       plus, minus, mult, divide, sustained-event.";
  }

  identity sustained-event {
    description
      "Identity for standard sustained-event function call,
       the input variables for sustained-event include string
       expr, number interval, number count. Keep testing
       expression 'expr'once per interval until false result
       reached.Return true if condition tested true
       for count intervals; Returns false otherwise.";
  }

  identity plus {
    description
      "Identity for standard plus function call, the input
       variables for plus function call include src policy argument
       and dst policy arugment.";
  }

  identity minus {
    description
      "Identity for standard minus function call, the input
       variables for plus function call include src policy argument
       and dst policy arugment.";
  }

  identity multiply {
    description
      "Identity for standard multiply function call, the input
       variables for multiply function call include src policy argument
       and dst policy arugment.";
  }

  identity divide {
    description
      "Identity for standard divide function call, the input
       variables for multiply function call include src policy argument
       and dst policy arugment.";
  }

  identity action-type {
    description
      "Possible values are:
       action, function-call, rpc.";
  }

  identity event-type {
    description
      "Base identity for Event Type.";
  }

  identity server-event {
    base event-type;
    description
      "Identity for server event.";
  }

  identity datastore-event {
    base event-type;
    description
      "Identity for datastore event.";
  }

  identity timer-event {
    base event-type;
    description
      "Identity for timer event.";
  }

  identity diagnostics-event {
    base event-type;
    description
      "Identity for diagnostics event.";
  }
  
  identity eca-exception-reason {
     description
       "Base of all values for the 'reason' leaf in the
       eca-exception notification.";
   }

   identity varbind-unknown {
     base eca-exception-reason;
     description
       "The requested policy variable binding is not defined.
        The variable binding cannot be resolved in the XPath
        evaluation.";
   }

  typedef centiseconds {
    type uint32;
    description
      "A period of time, measured in units of 0.01 seconds.";
  }

  typedef oper-status {
    type enumeration {
      enum completed {
        description
          "Completed with no error.";
      }
      enum running {
        description
          "Currently with no error.";
      }
      enum sleeping {
        description
          "Sleeping because of time schedule.";
      }
      enum stoped {
        description
          "Stopped by the operator.";
      }
      enum failed {
        description
          "Failed with errors.";
      }
      enum error-handling {
        description
          "Asking the operator to handle an error.";
      }
    }
    description
      "The operational status of an ECA execution.";
  }

      grouping scalar-value {
      leaf scalar-value {
        type string;
        description
          "Represents an XPath simple value that has an
           XPath type of Boolean, String, or Number.
           This value will be converted to an XPath type,
           as needed.

           A YANG value is encoded as a string using the same
           rules as the 'default' value for the data type.

           An eca-exception notification is generated if a scalar
           XPath value is used in a path expression, where a
           node-set is expected. Normally XPath will treat this result
           as an empty node-set, but this is an ECA programming error.";
      }
    }

    grouping nodeset-value {
      anydata nodeset-value {
         description
           "Represents an XPath node set. A 'node-set' anydata node
            with no child data nodes represents an empty node-set.
            Each child node in within this anydata structure
            represents a subtree that is present in the XPath
            node-set.

            An XPath node-set is not required to contain a top-level
            YANG data node.  It is not required to contain an entire
            complete subtree.

            It is am implementation-specific manner how a
            representation of YANG 'anydata' nodes are mapped
            to specific YANG module schema definitions.";
      }
    }
      grouping scalar-constant {
      leaf scalar-constant {
        type string;
        description
          "Represents an XPath simple value that has an
           XPath type of Boolean, String, or Number.
           This value will be converted to an XPath type,
           as needed.

           A YANG value is encoded as a string using the same
           rules as the 'default' value for the data type.

           An eca-exception notification is generated if a scalar
           XPath value is used in a path expression, where a
           node-set is expected. Normally XPath will treat this result
           as an empty node-set, but this is an ECA programming error.";
      }
    }

    grouping nodeset-constant {
      anydata nodeset-constant {
         description
           "Represents an XPath node set. A 'node-set' anydata node
            with no child data nodes represents an empty node-set.
            Each child node in within this anydata structure
            represents a subtree that is present in the XPath
            node-set.

            An XPath node-set is not required to contain a top-level
            YANG data node.  It is not required to contain an entire
            complete subtree.

            It is am implementation-specific manner how a
            representation of YANG 'anydata' nodes are mapped
            to specific YANG module schema definitions.";
      }
    }
  grouping pv-source {
    choice pv-source {
      mandatory true;
      description
        "A PV source represents an XPath result, which contains
         one of four data types: Boolean, Number, String,
         and Node Set.  XPath defines mechanisms to covert
         values between these four types.

         The 'xpath-expr' leaf is used to assign the PV source
         to the result of an arbitrary XPath expression.
         The result of this expression evaluation is used
         internally as needed. The result may be any one of
         the XPath data types.

         The 'scalar-constant' leaf is used to represent a Boolean,
         String, or Number XPath constant value.

         The 'nodeset-constant' anydata structure is used to
         represent a constant XPath node-set.";

      leaf xpath-expr {
        type yang:xpath1.0;
        description
          "Contains an XPath expression that must be evaluated
           to produce an XPath value. [section X.X] describes
           the XPath execution environment used to process this
           object.";
      }

      case scalar-constant {
        uses scalar-constant;
      }
      case nodeset-constant {
        uses nodeset-constant;
      }
    }
  }

  grouping pv-result {
    choice pv-result {
      mandatory true;
      description
        "Represents the value of the result of an
         Policy Variable evaluation.

         The 'scalar-value' leaf is used to represent a Boolean,
         String, or Number XPath result value.

         The 'nodeset-value' anydata structure is used to represent
         an XPath node-set result.";

      case scalar-value {
        uses scalar-value;
      }
      case nodeset-value {
        uses nodeset-value;
      }
    }
  }
  
  grouping policy-variable-attributes {
    description
      "Defining the policy variable attributes, including name, type
       and value. These attributes are used as part of the Policy
       Variable (PV) definition.";
    leaf name {
      type string;
      description
        "A string to uniquely identify a Policy Variable (PV), either
         globally for a global PV, or within the soope of ECA for a
         local PV.";
    }
    choice xpath-value-choice {
      description
        "The type of a policy variable may be either a common
         primative type like boolean or a type from existing
         schema node referenced by an XPath string.";
      /*case scalar {
        uses scalar-value;
      }
      case nodeset {
        uses nodeset-value;
      }*/
    case policy-source {
    uses pv-source;
   }
   case policy-result {
     uses pv-result;
   }
    }  
  }
  
  grouping action-element-attributes {
    description
      "Grouping of action element attributes.";
    leaf action-type {
      type identityref {
        base action-type;
      }
      description
        "Identifies the action type.";
    }
    choice action-operation {
      description
        "The operation choices that an ECA Action can take.";
   case action {
         leaf next-period {
            type boolean;
            description
              "invoke the same eca recursively if the next period 
              is set to true.";
          }
            leaf action-name {
             type leafref {
               path "/gncd/actions/action/name";
             }
             description
               "The operation is to execute a configured ECA Action.";
           }
         } // action
    case function-call {
           container function-call {
             description
               "The operation is to call a function, which is of one of
                a few basic predefined types, such as plus, minus,
                multiply, devide, or remainder.";
             leaf function-name {
               type string;
               description
                 "The name of function call to be called";
              }
       leaf policy-source {
        type leafref {
         path "/gncd/policy-variables/policy-variable/name";
      }
     description
      "The policy source.";
    }
    leaf policy-result {
    type leafref {
      path "/gncd/policy-variables/policy-variable/name";
     }
     description
      "The policy result.";
    }
           }
         } // function-call
         case rpc-operation {
           container rpc-operation {
             description
               "The operation is to call an RPC, which is defined by
                a YANG module supported by the server.";
             leaf rpc-name {
               type string;
               description
                 "The name of the YANG RPC or YANG action to be
                  called.";
             }
             leaf nc-action-xpath {
               type string;
               description
                 "The location where the YANG action is defined.
                  This is used if and only if a YANG action is called.
                  This leaf is not set when a YANG RPC is called.";
             }
           }
         } // rpc-operation

      /*case notify-operation {
        container notify-operation {
          description
            "The operation is to send a YANG notification.";
          leaf name {
            type string;
            description
              "Name of the subscribed YANG notification.";
          }
          list policy-variable {
            key "name";
            description
              "A list of policy arguments carried in the notification
               message.";
            leaf name {
              type string;
              description
                "A string name used as the list key to form a list
                 of policy arguments.";
            }
          }
        }
      }*/
    }
  }

  grouping time-schedule-container {
    description
      "Grouping to define a container of a time schedule.";
    container time-schedule {
      presence "Presence indicates that the timer is enabled.";
      description
        "Specifying the time schedule to execute an ECA Action, or
         trigger an event.";
      leaf period {
        type centiseconds;
        description
          "Duration of time that should occur between periodic
           push updates, in units of 0.01 seconds.";
      }
    }
  }

  container gncd {
    nacm:default-deny-all;
    description
      "Top level container for Generalized Network Control Automation
       (gncd).";
    container policy-variables {
      description
        "Container of global Policy Variables (PVs).";
      list policy-variable {
        key "name";
        description
          "A list of global Policy Variables (PVs), with a string
           name as the entry key.";
        uses policy-variable-attributes;
      }
    }
    container events {
      description
        "Container of ECA events.";
      list event {
        key "event-name";
        description
          "A list of events used as the triggers of ECAs.";
        leaf event-name {
          type string;
          description
            "The name of the event.";
        }
        leaf event-type {
          type identityref {
            base event-type;
          }
          description
            "The type of the event.";
        }
        leaf-list policy-variable {
          type leafref {
            path "/gncd/policy-variables/"
              + "policy-variable/name";
             }
          description
           "global policy variables, which
            are shared by all ECA scripts.";
           }
        leaf-list local-policy-variable {
          type leafref {
            path "/gncd/ecas/eca/policy-variable/name";
          }
          description
            "local policy variables, which
             are kept within an ECA instance, and appears/
             disappears with start/stop of the ECA execution.";
        }

        choice type-choice {
          description
            "The type of an event, including server event and datastore event.";
          case server-event {
            leaf event-stream {
              type string;
              description
                "The name of a subscribed stream .";
            }
            leaf event-module {
              type string;
              description
                "The name of YANG data module associated with the subscribed
                 stream.";
            }
            anydata event {
              description
                "This anydata value MUST Contain the absolute XPath
                 expression identifying the element path to the node that is
                 associated with subscribed stream.";
            }
          }
          case datastore-event {
            leaf datatore {
              type string;
              description
                "The name of a datatore from which applications
                 subscribe to updates.";
            }
            leaf data-path {
              type string;
              description
                "The absolute XPath expression identifying the
                 element path to the node that is associated with
                 subscribed stream..";
            }
            anydata data {
              description
                "This anydata value MUST Contain the node that is
                            associated with the data path.";
            }
          }
          case timer-event;
          case diagnostics-event;
        }
      }
    }
    container conditions {
      description
        "Container of ECA Conditions.";
      list condition {
        key "name";
        description
          "A list of ECA Conditions.";
        leaf name {
          type string;
          description
            "A string name to uniquely identify an ECA Condition
             globally.";
        }
        choice expression-choice {
          description
            "The choices of expression format to specify a condition,
             which can be either a XPath string.";
          case xpath {
            leaf condition-xpath {
              type string;
              description
                "A XPath string, representing a logical expression,
                 which can contain comparisons of datastore values
                 and logical operations in the XPath format.";
            }
          }
        }
      }
    }
    container actions {
      description
        "Container of ECA Actions.";
        uses time-schedule-container {
          description
            "Specifying the time schedule to execute this ECA
             Action.
             If not specified, the ECA Action is executed one time immediately
             when it is called.";
        }
      list action {
        key "name";
        description
          "A list of ECA Actions.";
        leaf name {
          type string;
          description
            "A string name to uniquely identify an ECA Action
             globally.";
        }
        list action-element {
          key "name";
          description
            "A list of elements contained in an ECA Action. ";
          leaf name {
            type string;
            description
              "A string name to uniquely identify the action element
               within the scope of an ECA action.";
          }
          uses action-element-attributes;
        }
      }
    }
    container ecas {
      description
        "Container of ECAs.";
      list eca {
        key "name";
        description
          "A list of ECAs";
        leaf name {
          type string;
          description
            "A string name to uniquely identify an ECA globally.";
        }
     leaf username {
      type string;
         mandatory true;
         description
           "Name of the user for the session.";
       }
        leaf event-name {
          type string;
          mandatory true;
          description
            "The name of an event that triggers the execution of
             this ECA.";
        }
        list policy-variable {
          key "name";
          description
            "A list of ECA local Policy Variables (PVs), with a
             string name as the entry key.";
          leaf name {
          type leafref {
            path "/gncd/policy-variables/policy-variable/name";
         } 
       }
          leaf is-static {
            type boolean;
            description
              "'true' if the PV is static; 'false' if the PV is
               dynamic.
               A dynamic PV appears/disappears with the start/stop
               of the ECA execution; a static PV exists as long as
               the ECA is configured.";
          }
        }
        list condition-action {
          key "name";
            ordered-by user;
          description
            "A list of Condition-Actions, which are configured
             conditions each with associated actions to be executed
             if the condition is evaluated to TRUE. The server can do 
             multiple action when the condition is true. If the next-period
             is set to true, condition-action will be executed recursively.
             It is also possbile to require multiple conditions to be true
             in order to do one action.";
          leaf name {
            type string;
            description
              "A string name uniquely identify a Condition-Action
               within this ECA.";
          }
          leaf-list condition {
            type leafref {
              path "/gncd/conditions/condition/name";
            }
            description
              "The reference to a configured condition.";
          }
          leaf action {
            type leafref {
              path "/gncd/actions/action/name";
            }
            description
              "The reference to a configured action.";
          }
        }
        action start {
          description
            "Start to execute this ECA.";
        }
        action stop {
          description
            "Stop the execution of this ECA.";
        }
        action next-action {
          description
            "Resume the execution of this ECA to complete the next
             action.";
        }
      }
    }
 container eca-func-libs {
  description
    "Container of ECA Function Libraries.";
  list eca-function {
    key func-name;
    description
     "A list of ECA standard function.";
    leaf func-name {
     type string;
    description
    "A string name to uniquely identify an ECA standard function.";
   }
}
  list rpc-function {
    key rpc-name;
    description
     "A list of ECA standard function.";
    leaf rpc-name {
   type string;
   description
     "A string name to uniquely identify an ECA standard RPC.";
    }
  }
   leaf eca-name {
    type leafref {
     path "/gncd/ecas/eca/name";
    }
    description
     "The reference to a configured ECA.";
    }
   } // eca-scripts
  }
  
    notification eca-exception {
      description
        "This notification is sent when some error occurs
         while the server is processing ECA logic.";
       leaf reason {
         type identityref {
         base eca-exception-reason;
         }
       }
    }
 notification custom-notification {
      description
        "This notification is sent when some error occurs
         while the server is processing ECA logic.";
       leaf eventTime {
         type yang:date-and-time;
          description
           "The event occurrence time";
       }
      leaf event-type {
          type identityref {
            base event-type;
          }
          description
            "The type of the event.";
      }
       choice type-choice {
          description
            "The type of an event, including server event and datastore event.";
          case server-event {
            leaf event-stream {
              type string;
              description
                "The name of a subscribed stream .";
            }
            leaf event-module {
              type string;
              description
                "The name of YANG data module associated with the subscribed
                 stream.";
            }
            anydata event {
              description
                "This anydata value MUST Contain the absolute XPath
                 expression identifying the element path to the node that is
                 associated with subscribed stream.";
            }
          }
          case datastore-event {
            leaf datatore {
              type string;
              description
                "The name of a datatore from which applications
                 subscribe to updates.";
            }
            leaf data-path {
              type string;
              description
                "The absolute XPath expression identifying the
                 element path to the node that is associated with
                 subscribed stream..";
            }
            anydata data {
              description
                "This anydata value MUST Contain the node that is
                 associated with the data path.";
            }
          }
        }
    }
}</artwork>
      </figure>

      <t>&lt;CODE ENDS&gt;</t>
    </section>

    <section title="Security Considerations">
      <t>The YANG modules defined in this document MAY be accessed via the
      RESTCONF protocol [RFC8040] or NETCONF protocol ([RFC6241]). The lowest
      RESTCONF or NETCONF layer requires that the transport-layer protocol
      provides both data integrity and confidentiality, see Section 2 in
      [RFC8040] and [RFC6241]. The lowest NETCONF layer is the secure
      transport layer, and the mandatory-to-implement secure transport is
      Secure Shell (SSH)[RFC6242] . The lowest RESTCONF layer is HTTPS, and
      the mandatory-to-implement secure transport is TLS [RFC5246].</t>

      <t>The NETCONF access control model [RFC6536] provides the means to
      restrict access for particular NETCONF or RESTCONF users to a
      preconfigured subset of all available NETCONF or RESTCONF protocol
      operations and content.</t>

      <t>There are a number of data nodes defined in this YANG module that are
      writable/creatable/deletable (i.e., config true, which is the default).
      These data nodes may be considered sensitive or vulnerable in some
      network environments. Write operations (e.g., edit-config) to these data
      nodes without proper protection can have a negative effect on network
      operations. These are the subtrees and data nodes and their
      sensitivity/vulnerability: <list style="symbols">
          <t>/gnca:gncd/gnca:policy-variables/gnca:policy-variable/gnca:name</t>

          <t>/gnca:gncd/gnca:events/gnca:event/gnca:name</t>

          <t>/gnca:gncd/gnca:conditions/gnca:condition/gnca:name</t>

          <t>/gnca:gncd/gnca:actions/gnca:action/gnca:name</t>

          <t>/gnca:gncd/gnca:ecas/gnca:eca/gnca:name</t>

          <t>/gnca:gncd/gnca:ecas/gnca:eca/gnca:username</t>

          <t>/gnca:gncd/gnca:eca-func-libs/gnca:eca-function/gnca:func-name</t>
        </list></t>
    </section>

    <section title="IANA Considerations">
      <t>This document registers two URIs in the IETF XML registry <xref
      target="RFC3688"/>. Following the format in <xref target="RFC3688"/>,
      the following registrations are requested to be made:</t>

      <figure>
        <artwork>---------------------------------------------------------------------
   URI: urn:ietf:params:xml:ns:yang:ietf-eca
   Registrant Contact: The IESG.
   XML: N/A, the requested URI is an XML namespace.
---------------------------------------------------------------------</artwork>
      </figure>

      <t>This document registers one YANG module in the YANG Module Names
      registry <xref target="RFC6020"/>.</t>

      <figure>
        <artwork>---------------------------------------------------------------------
   Name:         ietf-eca
   Namespace:    urn:ietf:params:xml:ns:yang:ietf-eca
   Prefix:       gnca
   Reference:    RFC xxxx
---------------------------------------------------------------------</artwork>
      </figure>
    </section>

    <section title="Acknowledges">
      <t>Igor Bryskin, Xufeng Liu, Alexander Clemm, Henk Birkholz, Tianran
      Zhou contributed to an earlier version of [GNCA]. We would like to thank
      the authors of that document on event response behaviors delegation for
      material that assisted in thinking that helped improve this document. We
      also would like to thanks Jonathan Hansford for valuable review on
      introduction and terminology section.</t>
    </section>

    <section title="Contributors">
      <figure>
        <artwork>   Alexander Clemm
   Futurewei
   Email: ludwig@clemm.org

   Michale Wang
   Huawei
   Email:wangzitao@huawei.com

   Chongfeng Xie
   China Telecom
   Email: xiechf@ctbri.com.cn

   Xiaopeng Qin
   Huawei
   Huawei Bld., No.156 Beiqing Rd.
   Beijing  100095
   China
   qinxiaopeng@huawei.com

   Tianran Zhou
   Huawei
   Email: zhoutianran@huawei.com

   Aihua Guo
   Individual
   aihguo1@gmail.com

   Nicola Sambo
   Scuola Superiore Sant'Anna
   Via Moruzzi 1
   Pisa  56124
   Italy
   Email: nicola.sambo@sssup.it

   Giuseppe Fioccola
   Huawei Technologies
   Riesstrasse, 25
   Munich  80992
   Germany
   Email: giuseppe.fioccola@huawei.com</artwork>
      </figure>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate
          Requirement Levels</title>

          <author fullname="Scott Bradner" initials="S." surname="Bradner">
            <organization>Harvard University</organization>

            <address>
              <postal>
                <street>1350 Mass. Ave.</street>

                <street>Cambridge</street>

                <street>MA 02138</street>
              </postal>

              <phone>+1 617 495 3864</phone>

              <email>sob@harvard.edu</email>
            </address>
          </author>

          <date month="March" year="1997"/>

          <area>General</area>

          <keyword>keyword</keyword>

          <abstract>
            <t>In many standards track documents several words are used to
            signify the requirements in the specification. These words are
            often capitalized. This document defines these words as they
            should be interpreted in IETF documents. Authors who follow these
            guidelines should incorporate this phrase near the beginning of
            their document: <list>
                <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
                "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
                "OPTIONAL" in this document are to be interpreted as described
                in RFC 2119.</t>
              </list></t>

            <t>Note that the force of these words is modified by the
            requirement level of the document in which they are used.</t>
          </abstract>
        </front>
      </reference>

      <?rfc include="reference.RFC.7950.xml"?>

      <?rfc include="reference.RFC.3688.xml"?>

      <?rfc include="reference.RFC.6020.xml"?>

      <?rfc include="reference.RFC.6241.xml"?>

      <?rfc include="reference.RFC.6242.xml"?>

      <?rfc include="reference.RFC.6536.xml"?>

      <?rfc include="reference.RFC.3460.xml"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.5246.xml"?>

      <?rfc include="reference.RFC.8340.xml"?>

      <?rfc include="reference.RFC.8342.xml"?>

      <?rfc include="reference.RFC.8040.xml"?>
    </references>

    <section title="ECA Condition Expression Examples">
      <t>Here are two examples of Condition Expression:</t>

      <t>(a) a condition that only includes data store states and constants,
      for example: <figure>
          <artwork>TE metric of Link L in Topology T  greater than 100, 
it can be expressed as follows:

 "/nw:networks/nw:network[network-id='T']/nt:link[link-id='L']/tet:te\
 /tet:te-link-attributes/tet:te-delay-metric &gt; 100"</artwork>
        </figure></t>

      <t>(b) a condition that also includes a Policy Variable, for
      example:<figure>
          <artwork>Allocated bandwidth of Link L in Topology T greater than 75% of 
what is stored in Policy Variable B, it can be expressed as follows:

"/nw:networks/nw:network[network-id='T']/nt:link[link-id='L']/tet:te\
 /tet:te-link-attributes/tet:max-resv-link-bandwidth\
 &gt; (ietf-eca:policy-variables/policy-variable[name='B']/value) * 0.75" </artwork>
        </figure></t>
    </section>

    <section title="ECA Model Self Monitoring Usage Example">
      <figure>
        <artwork>  +---------------------------+
  |     Management System     |
  +---------------------------+
            |           
        ECA |           
      Model |           
            |           
            V           
 +----------------------^-----+
 |      Managed Device  |     |
 |                      |     |
 |    //--\\ Condition--+     |
 |   | Event|       /    \    |
 |   |      |-----&gt;|Actions   |
 |    \\--//        \    /    |
 |                   ----     |
 +----------------------------+ </artwork>
      </figure>

      <t> The management system designs a new ECA policy based on monitored
      objects in ietf-interfaces module that support threshold checking and
      pushes down the ECA policy to control interface behaviour in the managed
      device that supports NETCONF/RESTCONF protocol operation, i.e.,scan all
      interfaces for a certain type every 5 seconds and check the counters or
      status, return an array of interface entries (XPath node-set) that match
      the search and suppress reporting of duplicated events if all conditions
      are evaluated into true. The XML example snippet is shown as below:</t>

      <figure>
        <artwork>&lt;gnca&gt;
    &lt;policy-variables&gt;
        &lt;policy-variable&gt;
            &lt;name&gt;event-repeat-count&lt;/name&gt;
            &lt;scalar-constant&gt;0&lt;/scalar-constant&gt;
        &lt;/policy-variable&gt;
        &lt;policy-variable&gt;
            &lt;name&gt;interface-statistics-event&lt;/name&gt;
            &lt;xpath-expr&gt;if:interfaces/if:interface[if:type=if:gigabitEthernet,
     if:oper-status=down]&lt;/xpath-expr&gt;
        &lt;/policy-variable&gt;
    &lt;/policy-variables&gt;
    &lt;events&gt;
        &lt;event&gt;
            &lt;event-name&gt;interface-self-monitoring&lt;/event-name&gt;
            &lt;event-type&gt;server-event&lt;/event-type&gt;
            &lt;event-stream&gt;NETCONF&lt;/event-stream&gt;
            &lt;event-module&gt;ietf-interfaces&lt;/event-module&gt;
            &lt;event&gt;if:interfaces/if:interface[if:type=if:gigabitEthernet]&lt;/event&gt;
        &lt;/event&gt;
    &lt;/events&gt;
    &lt;conditions&gt;
        &lt;condition&gt;
            &lt;name&gt;if-monitoring-condition1&lt;/name&gt;
            &lt;condition-xpath&gt;event[if:oper-status=down]&lt;/condition-xpath&gt;
        &lt;/condition&gt;
        &lt;condition&gt;
            &lt;name&gt;if-monitoring-condition2&lt;/name&gt;
            &lt;condition-xpath&gt;event[if:oper-status!=down]&lt;/condition-xpath&gt;
        &lt;/condition&gt;
        &lt;condition&gt;
            &lt;name&gt;if-monitoring-condition3&lt;/name&gt;
            &lt;condition-xpath&gt;event-repeat-count &gt;1 &lt;/condition-xpath&gt;
        &lt;/condition&gt;
        &lt;condition&gt;
            &lt;name&gt;if-monitoring-condition4&lt;/name&gt;
            &lt;condition-xpath&gt;event-repeat-count &lt;1 &lt;/condition-xpath&gt;
        &lt;/condition&gt;
    &lt;/conditions&gt;
    &lt;actions&gt;
        &lt;time-schedule&gt;
            &lt;period&gt;5&lt;/period&gt;
        &lt;/time-schedule&gt;
        &lt;action&gt;
            &lt;name&gt;if-matched-statistics1&lt;/name&gt;
            &lt;action-element&gt;
                &lt;name&gt;event-filter-action&lt;/name&gt;
                &lt;func-name&gt;filtered-event&lt;/func-name&gt;
                &lt;policy-source&gt;interface-statistics-event&lt;/policy-source&gt;
                &lt;policy-result&gt;event&lt;/policy-result&gt;
            &lt;/action-element&gt;
            &lt;action-element&gt;
                &lt;name&gt;increment-action&lt;/name&gt;
                &lt;func-name&gt;increment-function&lt;/func-name&gt;
                &lt;policy-source&gt;event-repeat-count&lt;/policy-source&gt;
                &lt;policy-result&gt;event-repeat-count&lt;/policy-result&gt;
            &lt;/action-element&gt;
            &lt;action-element&gt;
                &lt;name&gt;suppress-action&lt;/name&gt;
                &lt;rpc-operation&gt;
                    &lt;name&gt;suppress-notification&lt;/name&gt;
                &lt;/rpc-operation&gt;
            &lt;/action-element&gt;
            &lt;action-element&gt;
                &lt;name&gt;continue-check-action&lt;/name&gt;
                &lt;func-name&gt;match-function&lt;/func-name&gt;
                &lt;policy-source&gt;interface-statistics-event&lt;/policy-source&gt;
                &lt;policy-source&gt;event-repeat-count&lt;/policy-source&gt;
                &lt;policy-result&gt;next-period&lt;/policy-result&gt;
            &lt;/action-element&gt;
        &lt;/action&gt;
        &lt;action&gt;
            &lt;name&gt;if-matched-statistics2&lt;/name&gt;
            &lt;action-element&gt;
                &lt;name&gt;event-filter-action&lt;/name&gt;
                &lt;func-name&gt;filtered-event&lt;/func-name&gt;
                &lt;policy-source&gt;interface-statistics-event&lt;/policy-source&gt;
                &lt;policy-result&gt;event&lt;/policy-result&gt;
            &lt;/action-element&gt;
            &lt;action-element&gt;
                &lt;name&gt;increment-action&lt;/name&gt;
                &lt;func-name&gt;increment-function&lt;/func-name&gt;
                &lt;policy-source&gt;event-repeat-count&lt;/policy-source&gt;
                &lt;policy-result&gt;event-repeat-count&lt;/policy-result&gt;
            &lt;/action-element&gt;
            &lt;action-element&gt;
                &lt;name&gt;continue-check-action&lt;/name&gt;
                &lt;func-name&gt;match-function&lt;/func-name&gt;
                &lt;policy-source&gt;interface-statistics-event&lt;/policy-source&gt;
                &lt;policy-source&gt;event-repeat-count&lt;/policy-source&gt;
                &lt;policy-result&gt;next-period&lt;/policy-result&gt;
            &lt;/action-element&gt;
        &lt;/action&gt;
        &lt;action&gt;
            &lt;name&gt;if-matched-statistics3&lt;/name&gt;
            &lt;action-element&gt;
                &lt;name&gt;decrement-action&lt;/name&gt;
                &lt;func-name&gt;decrement-function&lt;/func-name&gt;
                &lt;policy-source&gt;event-repeat-count&lt;/policy-source&gt;
                &lt;policy-result&gt;event-repeat-count&lt;/policy-result&gt;
            &lt;/action-element&gt;
            &lt;action-element&gt;
                &lt;name&gt;exit-action&lt;/name&gt;
                &lt;func-name&gt;exit-func&lt;/func-name&gt;
            &lt;/action-element&gt;
        &lt;/action&gt;
    &lt;/actions&gt;
    &lt;ecas&gt;
        &lt;eca&gt;
            &lt;name&gt;interface-eca-handling&lt;/name&gt;
            &lt;user-name&gt;Bob&lt;/user-name&gt;
            &lt;event-name&gt;interface-self-monitoring&lt;/event-name&gt;
            &lt;condition-action&gt;
                &lt;name&gt;smart-filter1&lt;/name&gt;
                &lt;condition&gt;if-monitoring-condition1&lt;/condition&gt;
                &lt;condition&gt;if-monitoring-condition3&lt;/condition&gt;
                &lt;action&gt;
                    &lt;name&gt;if-matched-statistics1&lt;/name&gt;
                    &lt;action-element&gt;
                        &lt;name&gt;event-filter-action&lt;/name&gt;
                    &lt;/action-element&gt;
                    &lt;action-element&gt;
                        &lt;name&gt;increment-action&lt;/name&gt;
                    &lt;/action-element&gt;
                    &lt;action-element&gt;
                        &lt;name&gt;suppress-action&lt;/name&gt;
                    &lt;/action-element&gt;
                    &lt;action-element&gt;
                        &lt;name&gt;continue-check-action&lt;/name&gt;
                    &lt;/action-element&gt;
                &lt;/action&gt;
            &lt;/condition-action&gt;
            &lt;condition-action&gt;
                &lt;name&gt;smart-filter2&lt;/name&gt;
                &lt;condition&gt;if-monitoring-condition1&lt;/condition&gt;
                &lt;condition&gt;if-monitoring-condition4&lt;/condition&gt;
                &lt;action&gt;
                    &lt;name&gt;if-matched-statistics2&lt;/name&gt;
                    &lt;action-element&gt;
                        &lt;name&gt;event-filter-action&lt;/name&gt;
                    &lt;/action-element&gt;
                    &lt;action-element&gt;
                        &lt;name&gt;increment-action&lt;/name&gt;
                    &lt;/action-element&gt;
                    &lt;action-element&gt;
                        &lt;name&gt;continue-check-action&lt;/name&gt;
                    &lt;/action-element&gt;
                &lt;/action&gt;
            &lt;/condition-action&gt;
            &lt;condition-action&gt;
                &lt;name&gt;smart-filter3&lt;/name&gt;
                &lt;condition&gt;if-monitoring-condition2&lt;/condition&gt;
                &lt;action&gt;
                    &lt;name&gt;if-matched-statistics3&lt;/name&gt;
                    &lt;action-element&gt;
                        &lt;name&gt;decrement-action&lt;/name&gt;
                    &lt;/action-element&gt;
                    &lt;action-element&gt;
                        &lt;name&gt;exit-action&lt;/name&gt;
                    &lt;/action-element&gt;
                &lt;/action&gt;
            &lt;/condition-action&gt;
        &lt;/eca&gt;
    &lt;/ecas&gt;
    &lt;eca-func-libs&gt;
        &lt;eca-function&gt;
            &lt;func-name&gt;filtered-event&lt;/func-name&gt;
        &lt;/eca-function&gt;
        &lt;eca-function&gt;
            &lt;func-name&gt;increment-function&lt;/func-name&gt;
        &lt;/eca-function&gt;
        &lt;eca-function&gt;
            &lt;func-name&gt;decrement-function&lt;/func-name&gt;
        &lt;/eca-function&gt;
        &lt;eca-function&gt;
            &lt;func-name&gt;exit-function&lt;/func-name&gt;
        &lt;/eca-function&gt;
        &lt;eca-function&gt;
            &lt;func-name&gt;match-function&lt;/func-name&gt;
        &lt;/eca-function&gt;
        &lt;eca-rpc&gt;
            &lt;rpc-name&gt;event-duplication-suppress&lt;/rpc-name&gt;
        &lt;/eca-rpc&gt;
        &lt;eca-name&gt;interface-eca-handling&lt;/eca-name&gt;
    &lt;/eca-func-libs&gt;
&lt;/gnca&gt;</artwork>
      </figure>

      <t>In this example, the event name is set to
      'interface-self-monitoring', the event type is set to 'server-event',
      the function name of ECA function libraries is set to 'sustained-event',
      'increment-function','decrement-function','match-function','exit-function'
      the rpc name of ECA function libarries is set to
      'event-duplication-suppress',the name of 'condition-action' is
      corresponding to standard function calls described avove. The pseudo
      code of ECA logic can be described as follows:<figure>
          <artwork>count = 0;
while { next-period = true}
if(interface is down ) {
      event= filtered event;
      count++;
      if(count &gt; 1){
       suppress event;
       next-period = true;
       continue;
     }else if( count &lt;= 1) {
      next-period = true;
      continue;
     }
   }else if ( interface is not down){
     next-period = false;
     count--;
     exit;
  }
}</artwork>
        </figure></t>
    </section>

    <section title="Changes between Revisions">
      <t>v09 - v10<list style="symbols">
          <t>Rewrite ECA Model Self Monitoring Usage Example;</t>

          <t>Reintroduce iterate action, function call and rpc call action
          type. These action types are exchanged between local client and the
          server.</t>

          <t>Move notification operation as separate notification since the
          notification is exchange between the management system and the
          server.</t>
        </list></t>

      <t>v08 - v09<list style="symbols">
          <t>Add ECA function libraries list in the ECA model.</t>

          <t>Subtree and data node path fixing in the security section.</t>
        </list></t>

      <t>v07 - v08<list>
          <t>Replace ECA model usage example with self monitoring usage
          example in the appendix.</t>

          <t>Clean up references.</t>

          <t>Add a new section to discuss Mapping Policy Variables to XPath
          Variables.</t>

          <t>Add a new section to discuss ECA XPath Context.</t>

          <t>Add a new section to discuss ECA Evaluation Exceptions.</t>

          <t>Rewrite Introduction to highlight elevator pitch.</t>

          <t>Replace implicit variable and explicit variable with pv-source
          variable and pv-result variable.</t>

          <t>Take out function-call, cleanup-condition-action list, execution
          list, policy argument container, eca-script list at this moment.</t>
        </list></t>

      <t>v06 - v07<list style="symbols">
          <t>Reuse alarm notification event received on an event stream (RFC
          8639) in ECA logic;</t>

          <t>Represent ECA condition expression only in the form of Xpath
          expression;</t>

          <t>Add ECA condition expression example in the appendix;</t>

          <t>Add ECA model usage example in the appendix;</t>

          <t>Remove the section to discuss the relation with YANG push;</t>

          <t>Remove the dependency to SUPA framework draft;</t>

          <t>Remove smart filter extension example in the Appendix.</t>

          <t>Bind ECA script with condition expression in the model.</t>
        </list></t>

      <t>v05 - v06<list style="symbols">
          <t>Decouple ECA model from NETCONF protocol and make it applicable
          to other network mangement protocols.</t>

          <t>Move objective section to the last section with additional
          generic objectives.</t>
        </list></t>

      <t>v04 - v05<list style="symbols">
          <t>Harmonize with draft-bryskin and add additional attributes in the
          models (e.g., policy variable, func call enhancement, rpc
          execution);</t>

          <t>ECA conditions part harmonization;</t>

          <t>ECA Event, Condition, Action, Policy Variable and Value
          definition;</t>

          <t>Change ietf-event.yang into ietf-eca.yang and remove
          ietf-event-trigger.yang</t>
        </list></t>

      <t>v02 - v03<list style="symbols">
          <t>Usage Example Update: add an usage example to introduce how to
          reuse the ietf-event-trigger module to define the
          subscription-notification smarter filter.</t>
        </list></t>

      <t>v01 - v02<list style="symbols">
          <t>Introduce the group-id which allow group a set of events that can
          be executed together</t>

          <t>Change threshold trigger condition into variation trigger
          condition to further clarify the difference between boolean trigger
          condition and variation trigger condition.</t>

          <t>Module structure optimization.</t>

          <t>Usage Example Update.</t>
        </list></t>

      <t>v00 - v01<list style="symbols">
          <t>Separate ietf-event-trigger.yang from Event management modeland
          ietf-event.yang and make it reusable in other YANG models.</t>

          <t>Clarify the difference between boolean trigger condition and
          threshold trigger condition.</t>

          <t>Change evt-smp-min and evt-smp-max into min-data-object and
          max-data-object in the data model.</t>
        </list></t>
    </section>
  </back>
</rfc>
