<?xml version="1.0" encoding="US-ASCII"?>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com)
     by Daniel M Kohn (private) -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>
<rfc category="std" docName="draft-wwx-netmod-event-yang-07" ipr="trust200902">
  <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <?rfc toc="yes" ?>

  <?rfc symrefs="yes" ?>

  <?rfc sortrefs="yes"?>

  <?rfc iprnotified="no" ?>

  <?rfc strict="yes" ?>

  <front>
    <title abbrev="ECA YANG">A YANG Data model for ECA Policy
    Management</title>

    <author fullname="Henk Birkholz" initials="H." surname="Birkholz">
      <organization>Fraunhofer SIT</organization>

      <address>
        <email>henk.birkholz@sit.fraunhofer.de</email>
      </address>
    </author>

    <author fullname="Michael Wang" initials="M." surname="Wang">
      <organization abbrev="Huawei">Huawei Technologies,Co.,Ltd</organization>

      <address>
        <postal>
          <street>101 Software Avenue, Yuhua District</street>

          <city>Nanjing</city>

          <region/>

          <code>210012</code>

          <country>China</country>
        </postal>

        <email>wangzitao@huawei.com</email>
      </address>
    </author>

    <author fullname="Qin Wu" initials="Q." surname="Wu">
      <organization>Huawei</organization>

      <address>
        <postal>
          <street>101 Software Avenue, Yuhua District</street>

          <city>Nanjing</city>

          <region>Jiangsu</region>

          <code>210012</code>

          <country>China</country>
        </postal>

        <email>bill.wu@huawei.com</email>
      </address>
    </author>

    <author fullname="Igor Bryskin" initials="I." surname="Bryskin">
      <organization>Individual</organization>

      <address>
        <email>i_bryskin@yahoo.com</email>
      </address>
    </author>

    <author fullname="Xufeng Liu" initials="X." surname="Liu">
      <organization>Volta Networks</organization>

      <address>
        <email>xufeng.liu.ietf@gmail.com</email>
      </address>
    </author>

    <author fullname="Benoit Claise" initials="B." surname="Claise">
      <organization>Cisco</organization>

      <address>
        <email>bclaise@cisco.com</email>
      </address>
    </author>

    <date year="2020"/>

    <area>OPS Area</area>

    <workgroup>NETMOD Working Group</workgroup>

    <keyword>RFC</keyword>

    <keyword>Request for Comments</keyword>

    <keyword>I-D</keyword>

    <keyword>Internet-Draft</keyword>

    <keyword>Event Condition Action YANG</keyword>

    <abstract>
      <t>RFC8328 defines a policy-based management framework that allows
      definition of a data model to be used to represent high-level, possibly
      network-wide policies. Policy discussed in RFC8328 are classified into
      imperative policy and declarative policy, Event Condition Action (ECA)
      policy is an typical example of imperative policy. This document defines
      a YANG data model for the ECA policy management. The ECA policy YANG
      provides the ability for the network management function (within a
      network element) to control the configuration and monitor state change
      and take simple and instant action on the server when a trigger
      condition on the system state is met.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t>Network management consists of using one or multiple device-,
      technology-, service specific policies to influence management behavior
      within the system and make sure policies are enforced or executed
      correctly.</t>

      <t>[RFC8328] defines a policy-based management framework that allow
      definition of a data model to be used to represent high-level, possibly
      network-wide policies. Policies discussed in [RFC8328] are classified
      into imperative policy and declarative policy. Declarative policy
      specifies the goals to be achieved but not how to achieve those goals
      while imperative policy specifies when Events are triggered and what
      actions must be performed on the occurrence of an event. Event Condition
      Action (ECA) policy is a typical example of imperative policy.</t>

      <t>Event-driven management of states of managed objects across a wide
      range of devices can be used to monitor state changes of managed objects
      or resource and automatic trigger of rules in response to events so as
      to better service assurance for customers and to provide rapid autonomic
      response that can exhibit self-management properties including
      self-configuration, self-healing, self-optimization, and
      self-protection. Following are some of the use-cases where such ECA
      Policy can be used:<list style="symbols">
          <t>To filter out of objects underneath a requested a subtree, the
          subscriber may use YANG Push smart filter to request the network
          server to monitor specific network management data objects and send
          updates only when the value falls within a certain range.</t>

          <t>To filter out of objects underneath a requested a subtree, the
          subscriber may use YANG Push smart filter to request the network
          server to monitor specific network management data objects and send
          updates only when the value exceeds a certain threshold for the
          first time but not again until the threshold is cleared.</t>

          <t>To provide rapid autonomic response that can exhibit
          self-management properties, the management system delegate event
          response behaviors (e.g., auto-recover from network failure) to the
          network device so that the network can react to network change as
          quickly as the event is detected. The event response behaviors
          delegation can be done using ECA policy,e.g., to preconfigure
          protection/ restoration capability on the network device.</t>

          <t>To perform troubleshoot failures (i.e., fault verification and
          localization) and provide root cause analysis, the management system
          monitoring specific network management data objects may request the
          network device to export state information of a set of managed data
          objects when the value of monitored data object exceeds a certain
          threshold.</t>

          <t>To set up an LSP and reserve resources within the network via
          NETCONF protocol operation, Path Computation API RPC model can be
          invoked to calculate a path meeting end-to-end network performance
          criteria.</t>
        </list></t>

      <t>This document defines a ECA Policy management YANG data model. The
      ECA Policy YANG provides the ability for the network management function
      (within a network element) to control the configurations and monitor
      state parameters and take simple and instant action on the server when a
      trigger condition on the system state is met.</t>

      <t>The data model in this document is designed to be compliant with the
      Network Management Datastore Architecture (NMDA) [RFC8342].</t>
    </section>

    <section title="Conventions used in this document">
      <section title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in [RFC2119]. In this
        document, these words will appear with that interpretation only when
        in ALL CAPS. Lower case uses of these words are not to be interpreted
        as carrying [RFC2119] significance.</t>

        <t>The following terms are defined in [RFC7950] [RFC3460] and are not
        redefined here: <list style="symbols">
            <t>Server</t>

            <t>Client</t>

            <t>Policy variable</t>

            <t>Policy value</t>

            <t>Implicit policy variable</t>

            <t>explicit policy variable</t>
          </list></t>

        <t>This document uses the following terms: <list style="hanging">
            <t hangText="Event:">Something that happens which may be of
            interest or trigger the invocation of the rule. A fault, an alarm,
            a change in network state, network security threat, hardware
            malfunction, buffer untilization crossing a threshold, network
            connection setup, an external input to the system, for
            example.<vspace blankLines="1"/></t>

            <t hangText="Condition:">Condition can be seen as a logical test
            that, if satisfied or evaluated to be true, cause the action to be
            carried out.<vspace blankLines="1"/></t>

            <t hangText="Action:">Updates or invocations on local managed
            object attributes.</t>
          </list></t>
      </section>

      <section title="Tree Diagrams">
        <t>Tree diagrams used in this document follow the notation defined in
        [RFC8340].</t>
      </section>
    </section>

    <section title="Relationship to YANG Push">
      <t>YANG-push mechanism provides a subscription service for updates from
      a datastore. And it supports two types of subscriptions which are
      distinguished by how updates are triggered: periodic and on-change.</t>

      <t>The on-change push allow receivers to receive updates whenever
      changes to target managed objects occur. This document specifies a
      mechanism that provides three trigger conditions: <list style="symbols">
          <t>Existence: When a specific managed object appears,disappear or
          object change, the trigger fires, e.g. reserved ports are
          configured.</t>

          <t>Boolean: The user can set the type of boolean operator (e.g.
          unequal, equal, less, less-or-equal, greater, greater-or-equal, etc)
          and preconfigured threshold value (e.g. Pre-configured threshold).
          If the value of a managed object meet Boolean conditions, the
          trigger fires, e.g., when the boolean operator type is 'less', the
          trigger will be fired if the value of managed object is less than
          the pre-configured Boolean value.</t>

          <t>Threshold: The user can set the rising threshold,the falling
          threshold, the delta rising threshold, the delta falling threshold.
          A threshold test regularly compares the value of the monitored
          object with the threshold values, e.g., an event is triggered if the
          value of the monitored object is greater than or equal to the rising
          threshold or an event is triggered if the difference between the
          current measurement value and the previous measurement value is
          smaller than or equal to the delta falling threshold.</t>
        </list></t>

      <t>In these three trigger conditions, existence with type set to object
      change is similar to on Push change.</t>

      <t>In addtion, the model defined in this document provides a method for
      closed loop network management automation which allows automatic trigger
      of rules in response to events so as to better service assurance for
      customers and to provide rapid autonomic response that can exhibit
      self-management properties including self-configuration, self-healing,
      self-optimization, and self-protection. The details of the usage example
      is described in Appendix A.</t>
    </section>

    <section title="Overview of ECA YANG Data Model">
      <t>A ECA policy rule is read as: when event occurs in a situation where
      condition is true, then action is executed. Therefore ECA comprises
      three key elements: event, associated conditions, and associated
      actions. These three elements should be pushed down and configured on
      the server by the client. If the action is rejected by the server duing
      ECA policy execution, the action should be rolled back and cleaned
      up.</t>

      <section title="ECA Policy Variable and Value">
        <t>ECA policy variable (PV) generically represents information that
        changes (or "varies"), and that is set or evaluated by software. ECA
        policy Value is used for modeling values and constants used in policy
        conditions and actions. In policy, conditions and actions can abstract
        information as "policy variables" to be evaluated in logical
        expressions, or set by actions, e.g., the Policy Condition has the
        semantics "variable matches value" while Policy Action has the
        semantics "set variable to value".</t>

        <t>In ECA, two type of policy variables are defined, implicit variable
        and explicit variable. Explicit variables are bound to exact data
        object instance in the model while implicit variables are defined and
        evaluated outside of a model. Each ECA policy variable has the
        following attributes:<list style="symbols">
            <t>Name with Globally unique or ECA unique scope ;</t>

            <t>Type either implicit or explicit; The implicit or explicit type
            can be further broken down into global or local.</t>

            <t>Value data stored in the policy variable structured according
            to the PV type. This structure can be used to keep intermediate
            results/meta data during the execution of an ECA policy.</t>
          </list></t>

        <t>The following operations are allowed with/on a PV: <list
            style="symbols">
            <t>initialize (with a constant/enum/identity);</t>

            <t>set (with contents of another same type PV);</t>

            <t>read (retrieve datastore contents pointed by the specified same
            type XPath/sub-tree);</t>

            <t>write (modify configuration data in the datastore with the PV's
            content/value);</t>

            <t>insert (PV's content into a same type list);</t>

            <t>iterate (copy into PV one by one same type list elements)</t>

            <t>function calls in a form of F(arg1,arg2,...), where F is an
            identity of a function from extendable function library,
            arg1,arg2,etc are PVs respectively, the function's input
            parameters, with the result returned in result policy
            variable.</t>
          </list></t>

        <t>PVs could be used as input/output of an ECA invoked RPC and policy
        argument in the func calls. PVs could also be a source of information
        sent to the client in notification messages.</t>

        <t>PVs could be used in condition expressions</t>

        <t>The model structure for the Policy Variable is shown below: <figure>
            <artwork>  +--rw policy-variables
  |  +--rw policy-variable* [name]
  |     +--rw name                string
  |     +--rw type?               identityref
  |     +--rw explict-variable?   yang:xpath1.0
  |     +--rw implict-variable?   identityref
  |     +--rw policy-value?       union</artwork>
          </figure></t>
      </section>

      <section title="ECA Event">
        <t>The ECA event are used to keep track of state of changes associated
        with one of multiple operational state data objects in the network
        device. Typical examples of ECA event include a fault, an alarm, a
        change in network state, network security threat, hardware
        malfunction, buffer utilization crossing a threshold, network
        connection setup, and an external input to the system.</t>

        <t>Each ECA Event has the following attributes:<list style="symbols">
            <t>name, the name of ECA event;</t>

            <t>type, either one time or peridic scheduling;</t>

            <t>group-id, which can be used to group a set of events that can
            be executed together,e.g., deliver a service or provide service
            assurance;</t>

            <t>scheduled-time,configuration scheduling - scheduling one time
            or periodic.</t>
          </list></t>

        <t>Nested-event are supported by allowing one event's trigger to
        reference other event's definitions using the call-event
        configuration. Called events apply their triggers and actions before
        returning to the calling event's trigger and resuming evaluation. If
        the called event is triggered, then it returns an effective boolean
        true value to the calling event. For the calling event, this is
        equivalent to a condition statement evaluating to a true value and
        evaluation of the event continues.</t>

        <t>All events specified in the ECA policy model are continuously
        monitored by the server.</t>

        <t>The model structure for the ECA Event is shown below:</t>

        <figure>
          <artwork>     +--rw event* [name type]
        +--rw name                 string
        +--rw type                 identityref
        +--rw event-description?   string
        +--rw group-id?            group-type
        +--rw explict-variable*    leafref
        +--rw clear?               boolean
        +--rw scheduled-time
        |  +--rw type?                  identityref
        |  +--rw periodic
        |  |  +--rw interval    uint32
        |  |  +--rw start?      yang:date-and-time
        |  |  +--rw end?        yang:date-and-time
        |  +--rw calendar-time
        |     +--rw month*          string
        |     +--rw day-of-month*   uint8
        |     +--rw day-of-week*    uint8
        |     +--rw hour*           uint8
        |     +--rw minute*         uint8
        |     +--rw second*         uint8
        |     +--rw start?          yang:date-and-time
        |     +--rw end?            yang:date-and-time
        +--ro last-event?          -&gt; /eca/event/name</artwork>
        </figure>
      </section>

      <section title="ECA Condition">
        <t>Condition can be seen as a logical test that, if satisfied or
        evaluated to be true, cause the action to be carried out. In this
        model, condition can be specified as logical combinations of the
        following three condition expressions:<list style="symbols">
            <t>Existence: An existence condition monitors and manages the
            absence, presence, and change of a data object, for example,
            interface status. When a monitored object is specified, the system
            reads the value of the monitored object regularly.<list
                style="symbols">
                <t>If the existence test type is Absent, the system triggers a
                network event and takes the specified action when the
                monitored object disappears.</t>

                <t>If the existence test type is Present, the system triggers
                a network event and takes the specified action when the
                monitored object appears.</t>

                <t>If the existence test type is Changed, the system triggers
                a network event and takes the specified action when the value
                of the monitored object changes.</t>
              </list></t>

            <t>Boolean: A Boolean test compares the value of the monitored
            object with the reference value and takes action according to the
            comparison result. The comparision hierarchy is logical
            hierarchies specified in a form of: <figure>
                <artwork>&lt;policy-variable&gt; &lt;relation&gt; &lt;policy-value&gt; or 
&lt;policy-variable1&gt; &lt;relation&gt; &lt;policy-variable2&gt;

relation is one of the comparison operations from the set: 
==, !=, &gt;, &lt;, &gt;=, &lt;=</artwork>
              </figure></t>

            <t>The operation types include unequal, equal, less, lessorequal,
            greater, and greaterorequal. For example, if the comparison type
            is equal, an event is triggered when the value of the monitored
            object equals the reference value. The event will not be triggered
            again until the value becomes unequal and comes back to equal.</t>

            <t>Threshold: A threshold trigger condition regularly compares the
            value of the monitored object with the threshold values , with one
            of the following mechanisms:<list style="symbols">
                <t>A rising event is triggered if the value of the monitored
                object is greater than or equal to the rising threshold.</t>

                <t>A falling event is triggered if the value of the monitored
                object is smaller than or equal to the falling threshold.</t>

                <t>A rising event is triggered if the difference between the
                current measurement value and the previous measurement value
                is greater than or equal to the delta rising threshold.</t>

                <t>A falling network event is triggered if the difference
                between the current measurement value and the previous
                measurement value is smaller than or equal to the delta
                falling threshold.</t>

                <t>A falling event is triggered if the values of the monitored
                object, the rising threshold, and the falling threshold are
                the same.</t>

                <t>A falling event is triggered if the delta rising threshold,
                the delta falling threshold, and the difference between the
                current sampled value and the previous sampled value is the
                same.</t>
              </list>If the value of the monitored object crosses a threshold
            multiple times in succession, the managed device triggers an event
            only for the first crossing.</t>
          </list></t>

        <t>In addition, logical operation type can be used to describe complex
        logical operations between different condition lists under the same
        event, for example, (condition A &amp; condition B) or condition
        C.</t>

        <t>The model structure for the condition is shown below: <figure>
            <artwork>        +--rw condition* [name]
        |  +--rw name                      string
        |  +--rw condition-description?    string
        |  +--rw logical-operation-type?   identityref
        |  +--rw call-event?               -&gt; ../../name
        |  +--rw (test)?
        |     +--:(existences)
        |     |  +--rw existences
        |     |     +--rw type?              enumeration
        |     |     +--rw policy-variable?   leafref
        |     +--:(boolean)
        |     |  +--rw boolean
        |     |     +--rw operator?          operator
        |     |     +--rw policy-value
        |     |     |  +--rw policy-argument
        |     |     |     +--rw (argument)?
        |     |     |        +--:(explict-variable)
        |     |     |        |  +--rw explict-variable?   leafref
        |     |     |        +--:(implict-variable)
        |     |     |        |  +--rw implict-variable?   leafref
        |     |     |        +--:(value)
        |     |     |           +--rw policy-value?       leafref
        |     |     +--rw policy-variable
        |     |        +--rw policy-argument
        |     |           +--rw (argument)?
        |     |              +--:(explict-variable)
        |     |              |  +--rw explict-variable?   leafref
        |     |              +--:(implict-variable)
        |     |                 +--rw implict-variable?   leafref
        |     +--:(threshold)
        |        +--rw threshold
        |           +--rw rising-value?                    leafref
        |           +--rw rising-policy-variable*          leafref
        |           +--rw falling-value?                   leafref
        |           +--rw falling-policy-variable*         leafref
        |           +--rw delta-rising-value?              leafref
        |           +--rw delta-rising-policy-variable*    leafref
        |           +--rw delta-falling-value?             leafref
        |           +--rw delta-falling-policy-variable*   leafref
        |           +--rw startup?                         enumeration   </artwork>
          </figure></t>
      </section>

      <section title="ECA Action">
        <t>The action list consists of updates or invocations on local managed
        object attributes and a set of actions are defined as follows, which
        will be performed when the corresponding event is triggered:<list
            style="symbols">
            <t>sending one time log notification</t>

            <t>(-re)configuration - modifying a configuration data in the
            conventional configuration datastore.</t>

            <t>adding/removing event notify subscription (essentially, the
            same action as performed when a client explicitly adds/removes a
            subscription)</t>

            <t>executing an RPC defined by a YANG module supported by the
            server (the same action as performed when a client interactively
            calls the RPC);</t>

            <t>performing operations and function calls on PVs (such as
            assign, read, insert, iterate, etc);</t>
          </list></t>

        <t>Multiple ECA Actions could be triggered by a single ECA event.</t>

        <t>Any given ECA Condition or Action may appear in more than one
        ECAs.</t>

        <t>The model structure for the actions is shown below: <figure>
            <artwork>        +--rw actions
           +--rw action* [name]
              +--rw name                        string
              +--rw (action-type)?
                 +--:(set)
                 |  +--rw set
                 |     +--rw policy-variable?   leafref
                 |     +--rw value?             &lt;anydata&gt;
                 +--:(logging)
                 |  +--rw logging
                 |     +--rw type?              logging-type
                 |     +--rw policy-variable?   leafref
                 +--:(function-call)
                 |  +--rw function-call
                 |     +--rw function-type?     identityref
                 |     +--rw policy-argument* [name]
                 |     |  +--rw name                      string
                 |     |  +--rw (argument)?
                 |     |     +--:(explict-variable)
                 |     |     |  +--rw explict-variable?   leafref
                 |     |     +--:(implict-variable)
                 |     |     |  +--rw implict-variable?   leafref
                 |     |     +--:(value)
                 |     |        +--rw policy-value?       leafref
                 |     +--rw result
                 |        +--rw (argument)?
                 |           +--:(explict-variable)
                 |           |  +--rw explict-variable?   leafref
                 |           +--:(implict-variable)
                 |           |  +--rw implict-variable?   leafref
                 |           +--:(value)
                 |              +--rw policy-value?       leafref
                 +--:(rpc-call)
                    +--rw rpc-call
                       +--rw name?     string
                       +--rw input
                       |  +--rw policy-argument* [name]
                       |     +--rw name
                       |     |       string
                       |     +--rw (argument)?
                       |        +--:(explict-variable)
                       |        |  +--rw explict-variable?   leafref
                       |        +--:(implict-variable)
                       |        |  +--rw implict-variable?   leafref
                       |        +--:(value)
                       |           +--rw policy-value?       leafref
                       +--rw output
                          +--rw policy-argument* [name]
                             +--rw name
                             |       string
                             +--rw (argument)?
                                +--:(explict-variable)
                                |  +--rw explict-variable?   leafref
                                +--:(implict-variable)
                                |  +--rw implict-variable?   leafref
                                +--:(value)
                                   +--rw policy-value?       leafref</artwork>
          </figure></t>
      </section>
    </section>

    <section title="ECA YANG Model (Tree Structure)">
      <t>The following tree diagrams [RFC8340] provide an overview of the data
      model for the "ietf-eca" module. <figure>
          <artwork>  grouping start-end-grouping
    +-- start?   yang:date-and-time
    +-- end?     yang:date-and-time
  grouping existences-trigger
    +-- existences
       +-- type?              enumeration
       +-- policy-variable?
               -&gt; /policy-variables/policy-variable/name
  grouping boolean-trigger
    +-- boolean
       +-- operator?          operator
       +-- policy-value
       |  +-- policy-argument
       |     +-- (argument)?
       |        +--:(explict-variable)
       |        |  +-- explict-variable?   leafref
       |        +--:(implict-variable)
       |        |  +-- implict-variable?   leafref
       |        +--:(value)
       |           +-- policy-value?       leafref
       +-- policy-variable
          +-- policy-argument
             +-- (argument)?
                +--:(explict-variable)
                |  +-- explict-variable?   leafref
                +--:(implict-variable)
                   +-- implict-variable?   leafref
  grouping threshold-trigger
    +-- threshold
       +-- rising-value?
       |       -&gt; /policy-variables/policy-variable/policy-value
       +-- rising-policy-variable*
       |       -&gt; /policy-variables/policy-variable/name
       +-- falling-value?
       |       -&gt; /policy-variables/policy-variable/policy-value
       +-- falling-policy-variable*
       |       -&gt; /policy-variables/policy-variable/name
       +-- delta-rising-value?
       |       -&gt; /policy-variables/policy-variable/policy-value
       +-- delta-rising-policy-variable*
       |       -&gt; /policy-variables/policy-variable/name
       +-- delta-falling-value?
       |       -&gt; /policy-variables/policy-variable/policy-value
       +-- delta-falling-policy-variable*
       |       -&gt; /policy-variables/policy-variable/name
       +-- startup?                         enumeration
  grouping trigger-grouping
    +-- (test)?
       +--:(existences)
       |  +-- existences
       |     +-- type?              enumeration
       |     +-- policy-variable?
       |             -&gt; /policy-variables/policy-variable/name
       +--:(boolean)
       |  +-- boolean
       |     +-- operator?          operator
       |     +-- policy-value
       |     |  +-- policy-argument
       |     |     +-- (argument)?
       |     |        +--:(explict-variable)
       |     |        |  +-- explict-variable?   leafref
       |     |        +--:(implict-variable)
       |     |        |  +-- implict-variable?   leafref
       |     |        +--:(value)
       |     |           +-- policy-value?       leafref
       |     +-- policy-variable
       |        +-- policy-argument
       |           +-- (argument)?
       |              +--:(explict-variable)
       |              |  +-- explict-variable?   leafref
       |              +--:(implict-variable)
       |                 +-- implict-variable?   leafref
       +--:(threshold)
          +-- threshold
             +-- rising-value?                    leafref
             +-- rising-policy-variable*
             |       -&gt; /policy-variables/policy-variable/name
             +-- falling-value?                   leafref
             +-- falling-policy-variable*
             |       -&gt; /policy-variables/policy-variable/name
             +-- delta-rising-value?              leafref
             +-- delta-rising-policy-variable*
             |       -&gt; /policy-variables/policy-variable/name
             +-- delta-falling-value?             leafref
             +-- delta-falling-policy-variable*
             |       -&gt; /policy-variables/policy-variable/name
             +-- startup?                         enumeration

module: ietf-eca
  +--rw policy-variables
  |  +--rw policy-variable* [name]
  |     +--rw name                string
  |     +--rw type?               identityref
  |     +--rw explict-variable?   yang:xpath1.0
  |     +--rw implict-variable?   identityref
  |     +--rw policy-value?       union
  +--rw eca
     +--rw event* [name type]
        +--rw name                 string
        +--rw type                 identityref
        +--rw event-description?   string
        +--rw group-id?            group-type
        +--rw explict-variable*    leafref
        +--rw clear?               boolean
        +--rw scheduled-time
        |  +--rw type?                  identityref
        |  +--rw periodic
        |  |  +--rw interval    uint32
        |  |  +--rw start?      yang:date-and-time
        |  |  +--rw end?        yang:date-and-time
        |  +--rw calendar-time
        |     +--rw month*          string
        |     +--rw day-of-month*   uint8
        |     +--rw day-of-week*    uint8
        |     +--rw hour*           uint8
        |     +--rw minute*         uint8
        |     +--rw second*         uint8
        |     +--rw start?          yang:date-and-time
        |     +--rw end?            yang:date-and-time
        +--ro last-event?          -&gt; /eca/event/name
        +--ro last-condition?      -&gt; /eca/event/condition/name
        +--ro last-action?
        |       -&gt; /eca/event/actions/action/name
        +--rw condition* [name]
        |  +--rw name                      string
        |  +--rw condition-description?    string
        |  +--rw logical-operation-type?   identityref
        |  +--rw call-event?               -&gt; ../../name
        |  +--rw (test)?
        |     +--:(existences)
        |     |  +--rw existences
        |     |     +--rw type?              enumeration
        |     |     +--rw policy-variable?   leafref
        |     +--:(boolean)
        |     |  +--rw boolean
        |     |     +--rw operator?          operator
        |     |     +--rw policy-value
        |     |     |  +--rw policy-argument
        |     |     |     +--rw (argument)?
        |     |     |        +--:(explict-variable)
        |     |     |        |  +--rw explict-variable?   leafref
        |     |     |        +--:(implict-variable)
        |     |     |        |  +--rw implict-variable?   leafref
        |     |     |        +--:(value)
        |     |     |           +--rw policy-value?       leafref
        |     |     +--rw policy-variable
        |     |        +--rw policy-argument
        |     |           +--rw (argument)?
        |     |              +--:(explict-variable)
        |     |              |  +--rw explict-variable?   leafref
        |     |              +--:(implict-variable)
        |     |                 +--rw implict-variable?   leafref
        |     +--:(threshold)
        |        +--rw threshhold
        |           +--rw rising-value?                    leafref
        |           +--rw rising-policy-variable*          leafref
        |           +--rw falling-value?                   leafref
        |           +--rw falling-policy-variable*         leafref
        |           +--rw delta-rising-value?              leafref
        |           +--rw delta-rising-policy-variable*    leafref
        |           +--rw delta-falling-value?             leafref
        |           +--rw delta-falling-policy-variable*   leafref
        |           +--rw startup?
        |                   enumeration
        +--rw actions
           +--rw action* [name]
              +--rw name                   string
              +--rw (action-type)?
                 +--:(set)
                 |  +--rw set
                 |     +--rw policy-variable?   leafref
                 |     +--rw value?             &lt;anydata&gt;
                 +--:(logging)
                 |  +--rw logging
                 |     +--rw type?              logging-type
                 |     +--rw policy-variable?   leafref
                 +--:(function-call)
                 |  +--rw function-call
                 |     +--rw function-type?     identityref
                 |     +--rw policy-argument* [name]
                 |     |  +--rw name                      string
                 |     |  +--rw (argument)?
                 |     |     +--:(explict-variable)
                 |     |     |  +--rw explict-variable?   leafref
                 |     |     +--:(implict-variable)
                 |     |     |  +--rw implict-variable?   leafref
                 |     |     +--:(value)
                 |     |        +--rw policy-value?       leafref
                 |     +--rw result
                 |        +--rw (argument)?
                 |           +--:(explict-variable)
                 |           |  +--rw explict-variable?   leafref
                 |           +--:(implict-variable)
                 |           |  +--rw implict-variable?   leafref
                 |           +--:(value)
                 |              +--rw policy-value?       leafref
                 +--:(rpc-call)
                    +--rw rpc-call
                       +--rw name?     string
                       +--rw input
                       |  +--rw policy-argument* [name]
                       |     +--rw name
                       |     |       string
                       |     +--rw (argument)?
                       |        +--:(explict-variable)
                       |        |  +--rw explict-variable?   leafref
                       |        +--:(implict-variable)
                       |        |  +--rw implict-variable?   leafref
                       |        +--:(value)
                       |           +--rw policy-value?       leafref
                       +--rw output
                          +--rw policy-argument* [name]
                             +--rw name
                             |       string
                             +--rw (argument)?
                                +--:(explict-variable)
                                |  +--rw explict-variable?   leafref
                                +--:(implict-variable)
                                |  +--rw implict-variable?   leafref
                                +--:(value)
                                   +--rw policy-value?       leafref</artwork>
        </figure></t>
    </section>

    <section title="ECA YANG Module">
      <t>&lt;CODE BEGINS&gt; file "ietf-eca@2019-10-28.yang"</t>

      <figure>
        <artwork>module ietf-eca {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-eca";
  prefix eca;

  import ietf-yang-types {
    prefix yang;
  }

  organization
    "IETF NETMOD Working Group";
  contact
    "Editor:  Zitao Wang
              &lt;mailto:wangzitao@huawei.com&gt;
     Editor:  Qin Wu 
              &lt;mailto:bill.wu@huawei.com&gt;
     Editor:  Igor Bryskin
              &lt;mailto:Igor.Bryskin@huawei.com&gt;
     Editor:  Xufeng Liu
              &lt;mailto:xufeng.liu.ietf@gmail.com&gt;
     Editor:  Benoit Claise
               &lt;mailto:bclaise@cisco.com&gt;";
  description
    "  This module contains YANG specifications for ECA Policy management.
       Copyright (c) 2019 IETF Trust and the persons identified as
        authors of the code.  All rights reserved.

        Redistribution and use in source and binary forms, with or
        without modification, is permitted pursuant to, and subject to
        the license terms contained in, the Simplified BSD License set
        forth in Section 4.c of the IETF Trust's Legal Provisions
        Relating to IETF Documents
        (https://trustee.ietf.org/license-info).
       This version of this YANG module is part of RFC xxxx; see the
       RFC itself for full legal notices.";

  revision 2019-10-28 {
    description
      "Initial revision.";
    reference
      "RFC xxxx";
  }
  identity variable-type {
   description
   "base variable type";
  }
  identity global-explict {
   base variable-type;
   description
   "Identity for global explict variable";
  }
  identity global-implict {
   base variable-type;
   description
   "Identity for global explict variablae";
  }
  identity local-explict {
   base variable-type;
   description
   "Identity for local explict variable";
  }
  identity local-implict {
   base variable-type;
   description
   "Identity for local implict variable";
  }  
  identity function-type {
    description
      "Possible values are:
       plus, minus, mult, divide, remain.";
  }

  identity logical-operation-type {
    description
      "Possible values are:
       not, or, and.";
  }

  identity policy-variable-type {
    description
      "Possible values are:
       boolean, int32, int64, uint32, uint64, string, etc.";
  }

  identity event-type {
    description
      "Base identity for event type";
  }

  identity frequency {
    description
      "Base identity for frequency";
  }

  identity periodic {
    base frequency;
    description
      "Identity for periodic trigger";
  }

  identity scheduling {
    base frequency;
    description
      "Identity for scheduling trigger";
  }

  identity logging {
    description
      "Base identity for logging action";
  }

  identity logging-notification {
    base logging;
    description
      "Logging for event notification";
  }

  identity logging-set {
    base logging;
    description
      "Logging for reset values";
  }

  typedef logging-type {
    type identityref {
      base logging;
    }
    description
      "Logging types";
  }

  typedef group-type {
    type string;
    description
      "Group type";
  }

  grouping start-end-grouping {
    description
      "A grouping that provides start and end times for
       Event objects.";
    leaf start {
      type yang:date-and-time;
      description
        "The date and time when the Event object
         starts to create triggers.";
    }
    leaf end {
      type yang:date-and-time;
      description
        "The date and time when the Event object
         stops to create triggers.
         It is generally a good idea to always configure
         an end time and to refresh the end time as needed
         to ensure that agents that lose connectivity to
         their Controller do not continue executing Schedules
         forever.";
    }
  }

  typedef operator {
    type enumeration {
      enum unequal {
        description
          "Indicates that the comparision type is unequal to.";
      }
      enum equal {
        description
          "Indicates that the comparision type is equal to.";
      }
      enum less {
        description
          "Indicates that the comparision type is less than.";
      }
      enum less-or-equal {
        description
          "Indicates that the comparision type is less than
           or equal to.";
      }
      enum greater {
        description
          "Indicates that the comparision type is greater than.";
      }
      enum greater-or-equal {
        description
          "Indicates that the comparision type is greater than
           or equal to.";
      }
    }
    description
      "definition of the operator";
  }

  grouping existences-trigger {
    description
      "A grouping that provides existence trigger";
    container existences {
      leaf type {
        type enumeration {
          enum match {
          description "march";
          }
          enum mismatch {
          description "mismatch";
          }
        }
        description
          "existence type, variable match the value or variable mismatch the value";
      }
      leaf policy-variable {
        type leafref {
          path "/policy-variables/policy-variable/name";
        }
        description
          "Policy variable";
      }
      description
        "Container for existence";
    }
  }

  grouping boolean-trigger {
    description
      "A grouping that provides boolean trigger";
    container boolean {
      leaf operator {
        type operator;
        description
          "Comparison type.";
      }
      container policy-value {
        container policy-argument {
          choice argument {
            case explict-variable {
              leaf explict-variable {
                type leafref {
                  path "/policy-variables/policy-variable/explict-variable";
                }
                description
                  "explict variable";
              }
            }
            case implict-variable {
              leaf implict-variable {
                type leafref {
                  path "/policy-variables/policy-variable/implict-variable";
                }
                description
                  "implict variable";
              }
            }
            case value {
              leaf policy-value {
                type leafref {
                  path "/policy-variables/policy-variable/policy-value";
                }
                description
                  "policy value";
              }
            }
            description
              "Choice one argument format";
          }
          description
            "Cotainer for policy argument";
        }
        description
          "Container for policy value";
      }
      container policy-variable {
        container policy-argument {
          choice argument {
            case explict-variable {
              leaf explict-variable {
                type leafref {
                  path "/policy-variables/policy-variable/explict-variable";
                }
                description
                  "explict variable";
              }
            }
            case implict-variable {
              leaf implict-variable {
                type leafref {
                  path "/policy-variables/policy-variable/implict-variable";
                }
                description
                  "implict variable";
              }
            }
            description
              "Choice one argument format";
          }
          description
            "Cotainer for policy argument";
        }
        description
          "Container for policy variable";
      }
      description
        "Container for boolean test.";
    }
  }

  grouping threshold-trigger {
    description
      "A grouping that provides threshold trigger";
    container threshold {
      leaf rising-value {
        type leafref {
          path "/policy-variables/policy-variable/policy-value";
        }
        description
          "Sets the rising threshold to the specified value,
           when the current sampled value is greater than or equal to
           this threshold, and the value at the last sampling interval
           was less than this threshold, the event is triggered. ";
      }
      leaf-list rising-policy-variable {
        type leafref {
          path "/policy-variables/policy-variable/name";
        }
        description
          "List for target variable.";
      }
      leaf falling-value {
        type leafref {
          path "/policy-variables/policy-variable/policy-value";
        }
        description
          "Sets the falling threshold to the specified value.";
      }
      leaf-list falling-policy-variable {
        type leafref {
          path "/policy-variables/policy-variable/name";
        }
        description
          "List for target variable.";
      }
      leaf delta-rising-value {
        type leafref {
          path "/policy-variables/policy-variable/policy-value";
        }
        description
          "Sets the delta rising threshold to the specified value.";
      }
      leaf-list delta-rising-policy-variable {
        type leafref {
          path "/policy-variables/policy-variable/name";
        }
        description
          "List for target variable.";
      }
      leaf delta-falling-value {
        type leafref {
          path "/policy-variables/policy-variable/policy-value";
        }
        description
          "Sets the delta falling threshold to the specified value.";
      }
      leaf-list delta-falling-policy-variable {
        type leafref {
          path "/policy-variables/policy-variable/name";
        }
        description
          "List for target variable.";
      }
      leaf startup {
        type enumeration {
          enum rising {
            description
              "If the first sample after this
               managed object becomes active is greater than or equal
                to 'rising-value' and the 'startup' is equal to
                'rising' then one threshold rising event is
               triggered for that managed object.";
          }
          enum falling {
            description
              "If the first sample after this managed object becomes
               active is less than or equal to 'falling-value' and
               the 'startup' is equal to 'falling' then one
               threshold falling event is triggered for that managed
               object.";
          }
          enum rising-or-falling {
            description
              "That event may be triggered when the
               'startup' is equal to 'rising-or-falling'.
               'rising-or-falling' indicate the state value of the
                managed object may less than or greater than the
               specified thrshold value.";
          }
        }
        description
          "Startup setting.";
      }
      description
        "Container for the threshold trigger condition.
         Note that the threshold here  may change over time
         or the state value changes in either ascend order
         or descend order.";
    }
  }

  grouping trigger-grouping {
    description
      "A grouping that provides event trigger.";
    choice test {
      description
        "Choice test";
      case existences {
        uses existences-trigger;
      }
      case boolean {
        uses boolean-trigger;
      }
      case threshold {
        uses threshold-trigger;
      }
    }
  }

  container policy-variables {
    list policy-variable {
      key "name";
      leaf name {
        type string;
        description
          "Policy variable name";
      }
      leaf type {
        type identityref {
        base variable-type;
        }
        description
          "Policy variable type";
      }
      leaf explict-variable {
        type yang:xpath1.0;
        description
          "Explict policy variable";
      }
      leaf implict-variable {
        type identityref {
          base policy-variable-type;
        }
        description
          "A common policy variable type, defined as an
           identity.";
      }
      leaf policy-value {
        type union {
          type yang:xpath1.0;
          type yang:object-identifier;
          type yang:uuid;
          type string;
          type boolean;
          type int32;
          type int64;
          type uint32;
          type uint64;
        }
        description
          "Policy value";
      }
      description
        "List for policy variable";
    }
    description
      "Policy variables";
  }
  container eca {
    list event {
      key "name type";
      leaf name {
        type string;
        description
          "Event name";
      }
      leaf type {
        type identityref {
          base event-type;
        }
        description
          "Type of event";
      }
      leaf event-description {
        type string;
        description
          "Event description";
      }
      leaf group-id {
        type group-type;
        description
          "Group Identifier";
      }
      leaf-list explict-variable {
        type leafref {
          path "/policy-variables/policy-variable/explict-variable";
        }
        description
          "Explict variable";
      }
      leaf clear {
        type boolean;
        default "false";
        description
          "A flag indicate whether the event be closed";
      }
      container scheduled-time {
        leaf type {
          type identityref {
            base frequency;
          }
          description
            "Type of scheduled-time";
        }
        container periodic {
          when "derived-from-or-self(../type, 'periodic')";
          description
            "A periodic timing object triggers periodically
             according to a regular interval.";
          leaf interval {
            type uint32 {
              range "1..max";
            }
            units "seconds";
            mandatory true;
            description
              "The number of seconds between two triggers
               generated by this periodic timing object.";
          }
          uses start-end-grouping;
        }
        container calendar-time {
          when "derived-from-or-self(../type, 'scheduling')";
          description
            "A scheduling timing object triggers.";
          leaf-list month {
            type string;
            description
              "A set of months at which this scheduling timing
               will trigger.";
          }
          leaf-list day-of-month {
            type uint8 {
              range "0..59";
            }
            description
              "A set of days of the month at which this
               scheduling timing will trigger.";
          }
          leaf-list day-of-week {
            type uint8 {
              range "0..59";
            }
            description
              "A set of weekdays at which this scheduling timing
               will trigger.";
          }
          leaf-list hour {
            type uint8 {
              range "0..59";
            }
            description
              "A set of hours at which the scheduling timing will
               trigger.";
          }
          leaf-list minute {
            type uint8 {
              range "0..59";
            }
            description
              "A set of minutes at which this scheduling timing
               will trigger.";
          }
          leaf-list second {
            type uint8 {
              range "0..59";
            }
            description
              "A set of seconds at which this calendar timing
               will trigger.";
          }
          uses start-end-grouping;
        }
        description
          "Container for frequency";
      }
      leaf last-event {
        type leafref {
          path "/eca/event/name";
        }
        config false;
        description
          "The reference to a event last executed
           or being executed.";
      }
      leaf last-condition {
        type leafref {
          path "/eca/event/condition/name";
        }
        config false;
        description
          "The reference to a condition last executed or being
           executed.";
      }
      leaf last-action {
        type leafref {
          path "/eca/event/actions/action/name";
        }
        config false;
        description
          "The reference to aa action last executed or being
           executed.";
      }
      list condition {
        key "name";
        leaf name {
          type string;
          description
            "Trigger name";
        }
        leaf condition-description {
          type string;
          description
            "Trigger description";
        }
        leaf logical-operation-type {
          type identityref {
            base logical-operation-type;
          }
          description
            "The logical operation type.";
        }
        leaf call-event {
          type leafref {
            path "../../name";
          }
          description
            "This leaf call sub-event.";
        }
        uses trigger-grouping;
        description
          "List for trigger";
      }
      container actions {
        list action {
          key "name";
          leaf name {
            type string;
            description
              "Action Name";
          }
          choice action-type {
            description
              "Choice one action type";
            case set {
              container set {
                leaf policy-variable {
                  type leafref {
                    path "/policy-variables/policy-variable/name";
                  }
                  description
                    "The target objects";
                }
                anydata value {
                  description
                    "Inline set content.";
                }
                description
                  "Set a value to the target";
              }
            }
            case logging {
              container logging {
                leaf type {
                  type logging-type;
                  description
                    "Specifies the log action";
                }
                leaf policy-variable {
                  type leafref {
                    path "/policy-variables/policy-variable/name";
                  }
                  description
                    "The target objects";
                }
                description
                  "Specifies the log action";
              }
            }
            case function-call {
              container function-call {
                description
                  "The operation is to call a function, which is of one of
                   a few basic predefined types, such as plus, minus,
                   multiply, devide, or remainder.";
                leaf function-type {
                  type identityref {
                    base function-type;
                  }
                  description
                    "One of the predefined basic function types, such as
                     plus, minus, multiply, devide, or remainder.";
                }
                list policy-argument {
                  key "name";
                  leaf name {
                    type string;
                    description
                      "Policy argument name";
                  }
                  choice argument {
                    case explict-variable {
                      leaf explict-variable {
                        type leafref {
                          path "/policy-variables/policy-variable/explict-variable";
                        }
                        description
                          "explict variable";
                      }
                    }
                    case implict-variable {
                      leaf implict-variable {
                        type leafref {
                          path "/policy-variables/policy-variable/implict-variable";
                        }
                        description
                          "implict variable";
                      }
                    }
                    case value {
                      leaf policy-value {
                        type leafref {
                          path "/policy-variables/policy-variable/policy-value";
                        }
                        description
                          "policy value";
                      }
                    }
                    description
                      "Choice one argument format";
                  }
                  description
                    "List for policy argument";
                }
                container result {
                  choice argument {
                    case explict-variable {
                      leaf explict-variable {
                        type leafref {
                          path "/policy-variables/policy-variable/explict-variable";
                        }
                        description
                          "explict variable";
                      }
                    }
                    case implict-variable {
                      leaf implict-variable {
                        type leafref {
                          path "/policy-variables/policy-variable/implict-variable";
                        }
                        description
                          "implict variable";
                      }
                    }
                    case value {
                      leaf policy-value {
                        type leafref {
                          path "/policy-variables/policy-variable/policy-value";
                        }
                        description
                          "policy value";
                      }
                    }
                    description
                      "Choice one argument format";
                  }
                  description
                    "Container for result";
                }
              }
            }
            case rpc-call {
              container rpc-call {
                leaf name {
                  type string;
                  description
                    "The name of the YANG RPC or YANG action to be
                     called.";
                }
                container input {
                  list policy-argument {
                    key "name";
                    leaf name {
                      type string;
                      description
                        "Policy argument name";
                    }
                    choice argument {
                      case explict-variable {
                        leaf explict-variable {
                          type leafref {
                            path "/policy-variables/policy-variable/explict-variable";
                          }
                          description
                            "explict variable";
                        }
                      }
                      case implict-variable {
                        leaf implict-variable {
                          type leafref {
                            path "/policy-variables/policy-variable/implict-variable";
                          }
                          description
                            "implict variable";
                        }
                      }
                      case value {
                        leaf policy-value {
                          type leafref {
                            path "/policy-variables/policy-variable/policy-value";
                          }
                          description
                            "policy value";
                        }
                      }
                      description
                        "Choice one argument format";
                    }
                    description
                      "List for policy argument";
                  }
                  description
                    "Container for input";
                }
                container output {
                  list policy-argument {
                    key "name";
                    leaf name {
                      type string;
                      description
                        "Policy argument name";
                    }
                    choice argument {
                      case explict-variable {
                        leaf explict-variable {
                          type leafref {
                            path "/policy-variables/policy-variable/explict-variable";
                          }
                          description
                            "explict variable";
                        }
                      }
                      case implict-variable {
                        leaf implict-variable {
                          type leafref {
                            path "/policy-variables/policy-variable/implict-variable";
                          }
                          description
                            "implict variable";
                        }
                      }
                      case value {
                        leaf policy-value {
                          type leafref {
                            path "/policy-variables/policy-variable/policy-value";
                          }
                          description
                            "policy value";
                        }
                      }
                      description
                        "Choice one argument format";
                    }
                    description
                      "List for policy argument";
                  }
                  description
                    "Container for output";
                }
                description
                  "Container for rpc call";
              }
            }
          }
          description
            "List for actions";
        }
        description
          "Container for Actions";
      }
      description
        "List for Events";
    }
    description
      "YANG data module for defining event triggers and actions for
       network management purposes";
  }
}</artwork>
      </figure>

      <t>&lt;CODE ENDS&gt;</t>
    </section>

    <section title="Security Considerations">
      <t>The YANG modules defined in this document MAY be accessed via the
      RESTCONF protocol [RFC8040] or NETCONF protocol ([RFC6241]). The lowest
      RESTCONF or NETCONF layer requires that the transport-layer protocol
      provides both data integrity and confidentiality, see Section 2 in
      [RFC8040] and [RFC6241]. The lowest NETCONF layer is the secure
      transport layer, and the mandatory-to-implement secure transport is
      Secure Shell (SSH)[RFC6242] . The lowest RESTCONF layer is HTTPS, and
      the mandatory-to-implement secure transport is TLS [RFC5246].</t>

      <t>The NETCONF access control model [RFC6536] provides the means to
      restrict access for particular NETCONF or RESTCONF users to a
      preconfigured subset of all available NETCONF or RESTCONF protocol
      operations and content.</t>

      <t>There are a number of data nodes defined in this YANG module that are
      writable/creatable/deletable (i.e., config true, which is the default).
      These data nodes may be considered sensitive or vulnerable in some
      network environments. Write operations (e.g., edit-config) to these data
      nodes without proper protection can have a negative effect on network
      operations. These are the subtrees and data nodes and their
      sensitivity/vulnerability: <list style="symbols">
          <t>/eca/event/name</t>

          <t>/eca/policy-variables/policy-variable/name</t>

          <t>/eca/event/actions/action/name</t>

          <t>/eca/event/condition/name</t>
        </list></t>
    </section>

    <section title="IANA Considerations">
      <t>This document registers two URIs in the IETF XML registry <xref
      target="RFC3688"/>. Following the format in <xref target="RFC3688"/>,
      the following registrations are requested to be made:</t>

      <figure>
        <artwork>---------------------------------------------------------------------
   URI: urn:ietf:params:xml:ns:yang:ietf-eca
   Registrant Contact: The IESG.
   XML: N/A, the requested URI is an XML namespace.
---------------------------------------------------------------------</artwork>
      </figure>

      <t>This document registers one YANG module in the YANG Module Names
      registry <xref target="RFC6020"/>.</t>

      <figure>
        <artwork>---------------------------------------------------------------------
   Name:         ietf-eca
   Namespace:    urn:ietf:params:xml:ns:yang:ietf-eca
   Prefix:       eca
   Reference:    RFC xxxx
---------------------------------------------------------------------</artwork>
      </figure>
    </section>

    <section title="Acknowledges">
      <t>This work has benefited from the discussions of ECA Policy over the
      years. In particular, the SUPA project [
      https://datatracker.ietf.org/wg/supa/about/ ] provided approaches to
      express high-level, possibly network-wide policies to a network
      management function (within a controller, an orchestrator, or a network
      element).</t>

      <t>Igor Bryskin, Xufeng Liu, Alexander Clemm, Henk Birkholz, Tianran
      Zhou contributed to an earlier version of [GNCA]. We would like to thank
      the authors of that document on event response behaviors delegation for
      material that assisted in thinking that helped improve this
      document.</t>
    </section>

    <section title="Objectives for existing and possible future extension">
      <t>This section describes some of the design objectives for the ECA
      Policy management Data Model:<list style="symbols">
          <t>Clear and precise identification of Event types in the ECA
          Policy.</t>

          <t>Clear and precise identification of managed object (i.e., policy
          variable) in the ECA Policy.</t>

          <t>Allow nested ECA policy,e.g, one event to be able to call another
          nested event.</t>

          <t>Allow the client use NETCONF/RESTCONF protocol or any other
          management protocol to configure ECA Policy.</t>

          <t>Allow the server send updates only when the value falls within a
          certain range.</t>

          <t>Allow the server send updates only when the value exceeds a
          certain threshold for the first time but not again until the
          threshold is cleared.</t>

          <t>Allow the client optimize the system behavior across the whole
          network to meet objectives and provide some performance guarantees
          for network services.</t>

          <t>Allow the the server provide rapid autonomic response in the
          network device that can exhibit self-management properties including
          self-configuration, self-healing, self-optimization, and
          self-protection.</t>

          <t>Allow the ECA execution thread in the server use YANG Push/YANG
          Push extension to communicate with the client.</t>
        </list></t>
    </section>

    <section title="Contributors">
      <figure>
        <artwork>   Chongfeng Xie
   China Telecom
   Email: xiechf@ctbri.com.cn

   Xiaopeng Qin
   Huawei
   Huawei Bld., No.156 Beiqing Rd.
   Beijing  100095
   China
   qinxiaopeng@huawei.com

   Alexander Clemm
   Futurewei
   Email: ludwig@clemm.org

   Henk Birkholz
   Fraunhofer SIT
   Email: henk.birkholz@sit.fraunhofer.de

   Tianran Zhou
   Huawei
   Email: zhoutianran@huawei.com

   Aihua Guo
   Individual
   aihguo1@gmail.com

   Nicola Sambo
   Scuola Superiore Sant'Anna
   Via Moruzzi 1
   Pisa  56124
   Italy
   Email: nicola.sambo@sssup.it

   Giuseppe Fioccola
   Huawei Technologies
   Riesstrasse, 25
   Munich  80992
   Germany
   Email: giuseppe.fioccola@huawei.com</artwork>
      </figure>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate
          Requirement Levels</title>

          <author fullname="Scott Bradner" initials="S." surname="Bradner">
            <organization>Harvard University</organization>

            <address>
              <postal>
                <street>1350 Mass. Ave.</street>

                <street>Cambridge</street>

                <street>MA 02138</street>
              </postal>

              <phone>+1 617 495 3864</phone>

              <email>sob@harvard.edu</email>
            </address>
          </author>

          <date month="March" year="1997"/>

          <area>General</area>

          <keyword>keyword</keyword>

          <abstract>
            <t>In many standards track documents several words are used to
            signify the requirements in the specification. These words are
            often capitalized. This document defines these words as they
            should be interpreted in IETF documents. Authors who follow these
            guidelines should incorporate this phrase near the beginning of
            their document: <list>
                <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
                "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
                "OPTIONAL" in this document are to be interpreted as described
                in RFC 2119.</t>
              </list></t>

            <t>Note that the force of these words is modified by the
            requirement level of the document in which they are used.</t>
          </abstract>
        </front>
      </reference>

      <?rfc include="reference.RFC.7950.xml"?>

      <?rfc include="reference.RFC.7952.xml"?>

      <?rfc include="reference.RFC.3688.xml"?>

      <?rfc include="reference.RFC.6020.xml"?>

      <?rfc include="reference.RFC.6241.xml"?>

      <?rfc include="reference.RFC.6242.xml"?>

      <?rfc include="reference.RFC.6370.xml"?>

      <?rfc include="reference.RFC.6536.xml"?>

      <?rfc include="reference.RFC.2981.xml"?>

      <?rfc include="reference.RFC.8328.xml"?>

      <?rfc include="reference.RFC.3460.xml"?>
    </references>

    <section title="ECA Model Usage Example">
      <t><figure align="center">
          <artwork>  +---------------------------+
  |     Management System     |
  +---------------------------+
            |           
        ECA |           
      Model |           
            |           
            V           
 +----------------------^-----+
 |      Managed Device  |     |
 |                      |     |
 |    //--\\ Condition--+     |
 |   | Event|       /    \    |
 |   |      |-----&gt;|Actions   |
 |    \\--//        \    /    |
 |                   ----     |
 +----------------------------+         </artwork>
        </figure></t>

      <t>For Example:</t>

      <t>The management system push down one ECA policy to control interface
      behavior in the managed device that supports NETCONF protocol
      operation.</t>

      <t>The explicit policy variable of Event "interface-state-monitoring" is
      set to "/if:interfaces/if:interface[if:name='eth0']", the trigger list
      contains two conditions: 1)The publisher sends a push-change-update
      notification; 2) the value of "in-errors" of interface[name='eth0']
      exceeded the pre-configured threshold. When these conditions are met,
      corresponding action will be performed, i.e. disable
      interface[name='eth0']. The XML examples are shown as below:</t>

      <figure>
        <artwork>  &lt;notification xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0"&gt;
   &lt;eventTime&gt;2017-10-25T08:22:33.44Z&lt;/eventTime&gt;
   &lt;push-change-update
        xmlns="urn:ietf:params:xml:ns:yang:ietf-yang-push"&gt;
     &lt;id&gt;89&lt;/id&gt;
     &lt;datastore-changes&gt;
       &lt;yang-patch&gt;
         &lt;patch-id&gt;0&lt;/patch-id&gt;
         &lt;edit&gt;
           &lt;edit-id&gt;edit1&lt;/edit-id&gt;
           &lt;operation&gt;replace&lt;/operation&gt;
           &lt;target&gt;/ietf-interfaces:interfaces&lt;/target&gt;
           &lt;value&gt;
             &lt;interfaces
                  xmlns="urn:ietf:params:xml:ns:yang:ietf-interfaces"&gt;
               &lt;interface&gt;
                 &lt;name&gt;eth0&lt;/name&gt;
                 &lt;oper-status&gt;up&lt;/oper-status&gt;
               &lt;/interface&gt;
             &lt;/interfaces&gt;
           &lt;/value&gt;
         &lt;/edit&gt;
       &lt;/yang-patch&gt;
     &lt;/datastore-changes&gt;
   &lt;/push-change-update&gt;
  &lt;/notification&gt;

    &lt;eca&gt;
     &lt;event&gt;
     &lt;name&gt;interface-state-monitoring&lt;/name&gt;
     &lt;type&gt;interface-exception&lt;/type&gt;
     &lt;scheduled-time&gt;
     &lt;periodic&gt;
     &lt;interval&gt;10m&lt;/interval&gt;
     &lt;/periodic&gt;
     &lt;/scheduled-time&gt;
     &lt;condition&gt;
      &lt;name&gt;state-push-change&lt;/name&gt;
      &lt;condition-description&gt;sent a yang push
       \changed notification&lt;/condition-description&gt;
      &lt;test&gt;
       &lt;existence&gt;
       &lt;policy-variable&gt;/yp:notification/yp:push-change-update/yp:id[id=89]\
      /yp:datastore-changes/.../yp:target="/ietf-interfaces:interfaces='eth0'\
     &lt;/policy-variable&gt;
        &lt;/existence&gt;
      &lt;/test&gt;
     &lt;/explict-variable&gt;
     &lt;condition&gt;
      &lt;name&gt;evaluate-in-errors&lt;/name&gt;
      &lt;condition-description&gt;evaluate the number of
       the error packets&lt;/condition-description&gt;
      &lt;test&gt;
       &lt;boolean&gt;
        &lt;operator&gt;greater-or-equal&lt;/operator&gt;
        &lt;policy-value&gt;
         &lt;policy-argument&gt;
          &lt;policy-value&gt;100&lt;/policy-value&gt;
         &lt;/policy-argument&gt;
        &lt;/policy-value&gt;
        &lt;policy-variable&gt;
         &lt;policy-argument&gt;
         &lt;explict-variable&gt;/if:interfaces/if:interface[if:name='eth0']\
        /if:statistic/if:in-errors&lt;/explict-variable&gt;
         &lt;/policy-argument&gt;
        &lt;/policy-variable&gt;
       &lt;/boolean&gt;
      &lt;/test&gt;
     &lt;/condition&gt;
     &lt;action&gt;
      &lt;name&gt;foo&lt;/name&gt;
       &lt;set&gt;
        &lt;policy-variable&gt;/if:interfaces/if:interface[if:name='eth0']&lt;/policy-variable&gt;
        &lt;value&gt;
         &lt;interfaces&gt;
          &lt;interface&gt;
           &lt;name&gt;eth0&lt;/name&gt;
           &lt;enable&gt;false&lt;/enable&gt;
          &lt;/interface&gt;
         &lt;/interfaces&gt;
        &lt;/value&gt;
       &lt;/set&gt;
     &lt;/action&gt;
    &lt;/event&gt;
   &lt;/eca&gt;     </artwork>
      </figure>
    </section>

    <section title="Usage Example of Reusing Trigger-Grouping in smarter filter">
      <t>The "ietf-eca.yang" module defines a set of groupings for a generic
      condition expression. It is intended that these groupings can be reused
      by other models that require the trigger conditions, for example, in
      some subscription and notification cases, many applications do not
      require every update, only updates that are of certain interest. The
      following example describe how to reuse the "ietf-eca" module to define
      the subscription and notification smarter filter.</t>

      <figure>
        <artwork>  import ietf-subscribed-notifications {
     prefix sn;
  }
  import ietf-eca {
   prefix eca;
  }
   
  augment "/sn:subscriptions/sn:subscription" {
    description "add the smart filter container";
    container smart-filter {
       description "It concludes filter configurations";
       uses eca:trigger-grouping;
    }
  }      </artwork>
      </figure>

      <t>The tree diagrams:</t>

      <figure>
        <artwork>  module: ietf-smart-filter
  augment /sn:subscriptions/sn:subscription:
    +--rw smart-filter
      +-- (test)?
         +--:(existences)
         |  +-- existences
         |     +-- type?              enumeration
         |     +-- policy-variable?
         |             -&gt; /policy-variables/policy-variable/name
         +--:(boolean)
         |  +-- boolean
         |     +-- operator?          operator
         |     +-- policy-value
         |     |  +-- policy-argument
         |     |     +-- (argument)?
         |     |        +--:(explict-variable)
         |     |        |  +-- explict-variable?   leafref
         |     |        +--:(implict-variable)
         |     |        |  +-- implict-variable?   leafref
         |     |        +--:(value)
         |     |           +-- policy-value?       leafref
         |     +-- policy-variable
         |        +-- policy-argument
         |           +-- (argument)?
         |              +--:(explict-variable)
         |              |  +-- explict-variable?   leafref
         |              +--:(implict-variable)
         |                 +-- implict-variable?   leafref
         +--:(threshold)
            +-- threshold
               +-- rising-value?                    leafref
               +-- rising-policy-variable*
               |       -&gt; /policy-variables/policy-variable/name
               +-- falling-value?                   leafref
               +-- falling-policy-variable*
               |       -&gt; /policy-variables/policy-variable/name
               +-- delta-rising-value?              leafref
               +-- delta-rising-policy-variable*
               |       -&gt; /policy-variables/policy-variable/name
               +-- delta-falling-value?             leafref
               +-- delta-falling-policy-variable*
               |       -&gt; /policy-variables/policy-variable/name
               +-- startup?                         enumeration </artwork>
      </figure>
    </section>

    <section title="Changes between Revisions">
      <t>v05 - v06<list style="symbols">
          <t>Decouple ECA model from NETCONF protocol and make it applicable
          to other network mangement protocols.</t>

          <t>Move objective section to the last section with additional
          generic objectives.</t>
        </list></t>

      <t>v04 - v05<list style="symbols">
          <t>Harmonize with draft-bryskin and add additional attributes in the
          models (e.g., policy variable, func call enhancement, rpc
          execution);</t>

          <t>ECA conditions part harmonization;</t>

          <t>ECA Event, Condition, Action, Policy Variable and Value
          definition;</t>

          <t>Change ietf-event.yang into ietf-eca.yang and remove
          ietf-event-trigger.yang</t>
        </list></t>

      <t>v02 - v03<list style="symbols">
          <t>Usage Example Update: add an usage example to introduce how to
          reuse the ietf-event-trigger module to define the
          subscription-notification smarter filter.</t>
        </list></t>

      <t>v01 - v02<list style="symbols">
          <t>Introduce the group-id which allow group a set of events that can
          be executed together</t>

          <t>Change threshold trigger condition into variation trigger
          condition to further clarify the difference between boolean trigger
          condition and variation trigger condition.</t>

          <t>Module structure optimization.</t>

          <t>Usage Example Update.</t>
        </list></t>

      <t>v00 - v01<list style="symbols">
          <t>Separate ietf-event-trigger.yang from Event management modeland
          ietf-event.yang and make it reusable in other YANG models.</t>

          <t>Clarify the difference between boolean trigger condition and
          threshold trigger condition.</t>

          <t>Change evt-smp-min and evt-smp-max into min-data-object and
          max-data-object in the data model.</t>
        </list></t>
    </section>
  </back>
</rfc>
