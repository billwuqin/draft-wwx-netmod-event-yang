<?xml version="1.0" encoding="US-ASCII"?>
<!-- edited with XMLSPY v5 rel. 3 U (http://www.xmlspy.com)
     by Daniel M Kohn (private) -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC "" "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>
<rfc category="std" docName="draft-wwx-netmod-event-yang-09" ipr="trust200902">
  <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <?rfc toc="yes" ?>

  <?rfc symrefs="yes" ?>

  <?rfc sortrefs="yes"?>

  <?rfc iprnotified="no" ?>

  <?rfc strict="yes" ?>

  <front>
    <title abbrev="ECA YANG">A YANG Data model for ECA Policy
    Management</title>

    <author fullname="Andy Bierman" initials="A." surname="Bierman">
      <organization>YumaWorks</organization>

      <address>
        <email>andy@yumaworks.com</email>
      </address>
    </author>

    <author fullname="Qin Wu" initials="Q." surname="Wu">
      <organization>Huawei</organization>

      <address>
        <postal>
          <street>101 Software Avenue, Yuhua District</street>

          <city>Nanjing</city>

          <region>Jiangsu</region>

          <code>210012</code>

          <country>China</country>
        </postal>

        <email>bill.wu@huawei.com</email>
      </address>
    </author>

    <author fullname="Igor Bryskin" initials="I." surname="Bryskin">
      <organization>Individual</organization>

      <address>
        <email>i_bryskin@yahoo.com</email>
      </address>
    </author>

    <author fullname="Henk Birkholz" initials="H." surname="Birkholz">
      <organization>Fraunhofer SIT</organization>

      <address>
        <email>henk.birkholz@sit.fraunhofer.de</email>
      </address>
    </author>

    <author fullname="Xufeng Liu" initials="X." surname="Liu">
      <organization>Volta Networks</organization>

      <address>
        <email>xufeng.liu.ietf@gmail.com</email>
      </address>
    </author>

    <author fullname="Benoit Claise" initials="B." surname="Claise">
      <organization>Cisco</organization>

      <address>
        <email>bclaise@cisco.com</email>
      </address>
    </author>

    <date year="2020"/>

    <area>OPS Area</area>

    <workgroup>NETMOD Working Group</workgroup>

    <keyword>RFC</keyword>

    <keyword>Request for Comments</keyword>

    <keyword>I-D</keyword>

    <keyword>Internet-Draft</keyword>

    <keyword>Event Condition Action YANG</keyword>

    <abstract>
      <t>This document defines a YANG data model for the Event Condition
      Action (ECA) policy management. The ECA policy YANG provides the ability
      to delegate the network management function to the server and control
      the configuration and monitor state change and take simple and instant
      action on the server when a trigger condition on the system state is
      met.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="intro" title="Introduction">
      <t>Traditional approaches for network to automatically perform
      corrective actions in response to network events have been largely built
      on centralized policy based management [RFC3198]. With centralized
      network mangement, the managed object state or operational state
      spanning across the devices needs to be retrieved by the client from
      various different servers. However there are issues associated with
      centrallized network management:<list style="symbols">
          <t>Centralized network management incurs massive data collection and
          processing, the resource consumption (e.g., network bandwidth usage,
          the state to be maintained) is huge.</t>

          <t>Centralized network management leads to slow reaction to the
          network changes when large amount of managed object state from
          devices needs to collected and correlated at the central point where
          decisions about resource adjustment are made;</t>

          <t>Centralized network management can not control or influence
          management behavior within the server if the server is disconnected
          from any network or the existing configuration on the server has
          major errors;</t>

          <t>Centralized network management doesn't scale well when thousands
          of devices needs to send hundeds of event notifications or millions
          of managed data objects need to be polled by the client;</t>
        </list></t>

      <t>A more effective alternative to centralized network management is to
      delegate network management function to servers in the network and allow
      each server monitor state changes of managed objects. Accordingly there
      is a need for a service to provide continuous peformance monitoring and
      detect defects and failures and take corrective action.</t>

      <t>This document defines a ECA Policy management YANG data model. The
      ECA Policy YANG provides the ability to move the network management task
      to the server for self monitoring and self healing and control the
      configurations and monitor state parameters and take simple and instant
      action on the server when a trigger condition on the system state is
      met.</t>

      <t>The data model in this document is designed to be compliant with the
      Network Management Datastore Architecture (NMDA) [RFC8342].</t>
    </section>

    <section title="Conventions used in this document">
      <section title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in [RFC2119]. In this
        document, these words will appear with that interpretation only when
        in ALL CAPS. Lower case uses of these words are not to be interpreted
        as carrying [RFC2119] significance.</t>

        <t>The following terms are defined in [RFC7950] [RFC3460] and are not
        redefined here: <list style="symbols">
            <t>Server</t>

            <t>Client</t>

            <t>Policy variable</t>

            <t>Policy value</t>

            <t>Implicit policy variable</t>

            <t>explicit policy variable</t>
          </list></t>

        <t>This document uses the following terms: <list style="hanging">
            <t hangText="Event:">An event is something that happens that may
            be of interest - a configuration change, a fault, a change in
            status, crossing a threshold, or an external input to the system,
            for example. Often, this results in an asynchronous message,
            sometimes referred to as a notification or event notification,
            being sent to interested parties to notify them that this event
            has occurred [RFC5277].<vspace blankLines="1"/></t>

            <t hangText="Condition:">Condition can be seen as a logical test
            that, if satisfied or evaluated to be true, cause the action to be
            carried out.<vspace blankLines="1"/></t>

            <t hangText="Action:">Updates or invocations on local managed
            object attributes.</t>

            <t hangText="ECA Event:">The input to the ECA logic that initiates
            the processing Derived from extensible list of platform event
            types.</t>

            <t hangText="Server Event:">An event that happens in the server
            for which a Notification could be generated in an Event Stream
            subscription.</t>

            <t hangText="Datastore Event:">An event that happens within a
            datastore within the server for a Notification could be generated
            in a datastore subscription.</t>

            <t hangText="Timer Event:">A pseudo-event in the server that
            allows ECA logic to be invoked periodically.</t>

            <t hangText="Diagnostic Event:">A pseudo-event initiated by the
            client to test ECA logic.</t>

            <t hangText="Self Monitoring:">Automatic monitoring and control of
            resources to ensure the optimal functioning with respect to the
            defined requirements.</t>

            <t hangText="Self Healing:">Automatic discovery, and correction of
            faults; automatically applying all necessary actions to bring
            system back to normal operation.</t>

            <t hangText="Policy Variable (PV):">Represents datastore states
            that change (or "vary"), and that is set or evaluated by
            software.</t>

            <t hangText="PV-Source:">Represents an XPath result, which
            contains one of four data types: Boolean, Number, String, and Node
            Set.</t>

            <t hangText="PV-Result:">Represents the value of the result of an
            Policy Variable evaluation.</t>

            <t/>
          </list></t>
      </section>

      <section title="Tree Diagrams">
        <t>Tree diagrams used in this document follow the notation defined in
        [RFC8340].</t>
      </section>
    </section>

    <section title="Overview of ECA YANG Data Model">
      <t>A ECA policy rule is read as: when event occurs in a situation where
      condition is true, then action is executed. Therefore ECA comprises
      three key elements: event, associated conditions, and actions. These
      three elements should be pushed down and configured on the server by the
      client. If the action is rejected by the server duing ECA policy
      execution, the action should be rolled back and cleaned up.</t>

      <section title="ECA Policy Variable and Value">
        <t>ECA policy variable (PV) generically represents datastore states
        that change (or "vary"), and that is set or evaluated by software. The
        value of ECA policy variable is used for modeling values and constants
        used in policy conditions and actions. In policy, conditions and
        actions can abstract information as "policy variables" to be evaluated
        in logical expressions, or set by actions, e.g., the policy condition
        has the semantics "variable matches value" while policy action has the
        semantics "set variable to value".</t>

        <t>In ECA, two type of policy variables are defined, pv-source
        variable and pv-result variable. pv-source variable represents an
        XPath result, which contains one of four data types: Boolean, Number,
        String, and Node Set while pv-result variable represents the value of
        the result of an Policy Variable evaluation. <list style="symbols">
            <t>A pv-source is always config=true.</t>

            <t>A pv-result is always config=false.</t>

            <t>A single anydata cannot be used for all values since it is only
            allowed to contain child nodes. Separate scalar and nodeset values
            are needed.</t>
          </list>Each ECA policy variable has the following two
        attributes:<list style="symbols">
            <t>Name with Globally unique or ECA unique scope ;</t>

            <t>Type either pv-source or pv-result;</t>
          </list></t>

        <t>The following operations are allowed with/on a PV: <list
            style="symbols">
            <t>initialize (with a constant/enum/identity);</t>

            <t>set (with contents of another same type PV);</t>

            <t>read (retrieve datastore contents pointed by the specified same
            type XPath/sub-tree);</t>

            <t>write (modify configuration data in the datastore with the PV's
            content/value);</t>

            <t>insert (PV's content into a same type list);</t>

            <t>iterate (copy into PV one by one same type list elements)</t>

            <t>function calls in a form of F(arg1,arg2,...), where F is an
            identity of a function from extendable function library,
            arg1,arg2,etc are PVs respectively, the function's input
            parameters, with the result returned in result policy
            variable.</t>
          </list></t>

        <t>PVs could also be a source of information sent to the client in
        notification messages.</t>

        <t>PVs could be also used in condition expressions.</t>

        <t>The model structure for the Policy Variable is shown below: <figure>
            <artwork>     +--rw policy-variables
     |  +--rw policy-variable* [name]
     |     +--rw name                            string
     |     +--rw (xpath-value-choice)?
     |        +--:(policy-source)
     |        |  +--rw (pv-source)
     |        |     +--:(xpath-expr)
     |        |     |  +--rw xpath-expr?         yang:xpath1.0
     |        |     +--:(scalar-constant)
     |        |     |  +--rw scalar-constant?    string
     |        |     +--:(nodeset-constant)
     |        |        +--rw nodeset-constant?   &lt;anydata&gt;
     |        +--:(policy-result)
     |           +--rw (pv-result)
     |              +--:(scalar-value)
     |              |  +--rw scalar-value?       string
     |              +--:(nodeset-value)
     |                 +--rw nodeset-value?      &lt;anydata&gt;</artwork>
          </figure></t>
      </section>

      <section title="ECA Event">
        <t>The ECA Event is any subscribable event notification either
        explicitly defined in a YANG module (e.g., interface management model)
        supported by the server or a event stream conveyed to the server via
        YANG Push subscription. The ECA event are used to keep track of state
        of changes associated with one of multiple operational state data
        objects in the network device.</t>

        <t>Each ECA Event has the following attributes:<list style="symbols">
            <t>event-name, the name of ECA event;</t>

            <t>event-type, typical examples of ECA event type include server
            event, datastore event, timer event and diagnostic event.</t>

            <t>event-stream,in case of server event.</t>

            <t>event-module, in case of server event.</t>

            <t>event-name, in case of server event.</t>

            <t>event, it is event stream conveyed to the server in case of
            server event.</t>

            <t>datastore, in case of datastore event.</t>

            <t>data-path, in case of datastore event.</t>

            <t>data, it is event notification defined in a YANG module, in
            case of datastore event.</t>

            <t>period, in case of timer event.</t>
          </list></t>

        <t>A client may define an event of interest by making use of YANG PUSH
        subscription. Specifically, the client may configure an ECA event
        according to the ECA model specifying the event's name, as well as the
        name of corresponding PUSH subscrition. In this case, the server is
        expected to: <list style="symbols">
            <t>Register the event recording its name and using the referred
            PUSH subsription trigger as definition of the event firing
            trigger;</t>

            <t>Auto-configure the event's ECA input in the form of local PVs
            using the PUSH subscription's filters;</t>

            <t>At the moment of event firing intercept the notifications that
            would be normally sent to the PUSH subscription's client(s); copy
            the data store states pointed by the PUSH subscription's filters
            into the auto-configured ECA's local PVs and execute the ECA's
            condition-action chain.</t>
          </list></t>

        <t>All events (specified in at least one ECA pushed to the server) are
        required to be constantly monitored by the server. One way to think of
        this is that the server subscribes to its own publications with
        respect to all events that are associated with at least one ECA.</t>

        <t>The model structure for the ECA Event is shown below:</t>

        <figure>
          <artwork>     +--rw events
     |  +--rw event* [event-name]
     |     +--rw event-name               string
     |     +--rw event-type?              identityref
     |     +--rw policy-variable*         -&gt; /gncd/policy-variables/policy-variable/name
     |     +--rw local-policy-variable*   -&gt; /gncd/ecas/eca/policy-variable/name
     |     +--rw (type-choice)?
     |        +--:(server-event)
     |        |  +--rw event-stream?      string
     |        |  +--rw event-module?      string
     |        |  +--rw event?             &lt;anydata&gt;
     |        +--:(datastore-event)
     |        |  +--rw datatore?          string
     |        |  +--rw data-path?         string
     |        |  +--rw data?              &lt;anydata&gt;
     |        +--:(timer-event)
     |        |  +--rw time-schedule!
     |        |     +--rw period?   centiseconds
     |        |     +--rw count?    uint16
     |        +--:(diagnostics-event)</artwork>
        </figure>
      </section>

      <section title="ECA Condition">
        <t>The ECA Condition is the logical expression that is specified in a
        form of Xpath expression and evaluated to TRUE or FALSE. The XPath
        expression specifies an arbitrary logical/mathematical expression; The
        elements of the ECA Condition expression are referred by the XPaths
        pointing to referred datastore states.</t>

        <t>The ECA Condition expression in the form of XPath expression allows
        for specifying a condition of arbitrary complexity as a single string
        with an XPath expression, in which pertinent PVs and datastore states
        are referred to by their respective positions in the YANG tree.</t>

        <t>ECA Conditions are associated with ECA Events and evaluated only
        within event threads triggered by the event detection.</t>

        <t>When an ECA Condition is evaluated to TRUE, the associated ECA
        Action is executed.</t>

        <t>The model structure for the condition is shown below: <figure>
            <artwork>     +--rw conditions
     |  +--rw condition* [name]
     |     +--rw name                     string
     |     +--rw (expression-choice)?
     |        +--:(xpath)
     |           +--rw condition-xpath?   string
</artwork>
          </figure></t>

        <section title="Mapping Policy Variables to XPath Variables">
          <t>Policy variables are mapped to XPath variable bindings so they
          can be referenced in the XPath expression for a Condition.<list
              style="symbols">
              <t>The 'name' leaf value for the policy variable is mapped to
              the local-name of the XPath variable. No namespace is used for
              ECA varaibles. Eg., the policy variable named 'foo' would be
              accessible with a variable refernece '$foo'.</t>

              <t>The local-name 'USER' is reserved and defined in NACM. The
              server SHOULD provide the USER variable as NACM is
              implemented.</t>

              <t>The values of all available policy variables are updated by
              the server (if required) before the XPath expression is
              evaluated. The variable binding value MUST NOT change while the
              XPath expression is being evaluated. If multiple references to
              the same variable exist in an XPath expression, they MUST
              resolve to the same value in each instance.<figure>
                  <artwork>
Example:  "/test1[name=$badfan] and /test2[name=$badfan]"
     The same value of 'badfan' is expected in each instance.
</artwork>
                </figure></t>

              <t>If a variable reference cannot be resolved because no policy
              variable with that name is accessible to the ECA under
              evaluation, then an eca-exception notification SHOULD be
              generated, and the XPath evaluation MUST be terminated with an
              error.</t>

              <t>Example:<figure>
                  <artwork>[TBD: Need to determine what XPath parsers support.
 Need to support simple expressions like
    PV(x) = $A
    PV(x) = $A + $B

May need to wrapper in function calls

    PV(x) = number($A)
    PV(x) = number($A) + number($B)

TBD: How to do conditional assignments

   if nmda-supported()
     PV(top) = /interfaces
   else
     PV(top) = /interfaces-state
   end

Then an XPath expression can use

   $top/interface/name</artwork>
                </figure></t>
            </list></t>
        </section>

        <section title="ECA XPath Context">
          <t>All XPath expressions used in ECA share the following XPath
          context definition.<list style="symbols">
              <t>The set of namespace declarations is the set of all modules
              loaded into the server at the moment. Prefix bindings can
              reference the set of namespace URIs for this set of modules.</t>

              <t>All names SHOULD be namespace-qualified. There is no default
              namespace to use if no namespace is specified. If no namespace
              is used then the XPath step matches the local-name in all
              namespaces.</t>

              <t>The function library is the core function library defined in
              [XPATH], the functions defined in Section 10 of [RFC7950], and
              the ECALIB functions defined in this document <xref
              target="ecalib"/>.</t>

              <t>The set of variable bindings is set to all policy variables
              that are visible to the ECA under evaluation. This includes the
              local-policy-variable and policy-variable entries configured for
              the 'eca' entry. Since pv-source values can reference other
              policy variables, the order that these fields are set is
              significant.</t>

              <t>The accessible tree is all state data in the server, and the
              running configuration datastore. The root node has all top-level
              data nodes in all modules as children.</t>

              <t>The context node for all ECA XPath evaluation is the root
              node.</t>
            </list></t>
        </section>

        <section title="ECA Evaluation Exceptions">
          <t>Not all errors can be detected at configuration time. Error that
          occur while ECA logis is being evaluated will cause the server to
          generate an eca-exception notification.</t>

          <t>TBD: Does an exception cause the ECA entry to be disabled
          automatically?</t>

          <figure>
            <artwork>   identity eca-exception-reason {
     description
       "Base of all values for the 'reason' leaf in the
       eca-exception notification.";
   }

   identity varbind-unknown {
     base eca-exception-reason;
     description
       "The requested policy variable binding is not defined.
        The variable binding cannot be resolved in the XPath
        evaluation.";
   }

   // TBD: define exceptions as needed

    notification eca-exception {
      description
        "This notification is sent when some error occurs
         while the server is processing ECA logic.
         [TBD: lots more detail and parameters]";
       leaf reason {
         type eca-exception-reason;
       }
    }</artwork>
          </figure>
        </section>
      </section>

      <section title="ECA Action">
        <t>The ECA Action list consists of updates or invocations on local
        managed object attributes and a set of actions are defined as follows,
        which will be performed when the corresponding event is
        triggered:<list style="symbols">
            <t>sending one time notification</t>

            <t>(re-)configuration scheduling - scheduling one time or periodic
            (re-)configuration in the future</t>

            <t>stopping current ECA;</t>

            <t>invoking another ECA;</t>
          </list></t>

        <t>Three points are worth noting:<list style="symbols">
            <t>When a "Send notification" action is configured as an ECA
            Action, the notification message to be sent to the client may
            contain not only elements of the data store (as, for example, YANG
            PUSH or smart filter notifications do), but also the contents of
            global and local PVs, which store results of arbitrary operations
            performed on the data store contents (possibly over arbitrary
            period of time) to determine, for example, history/evolution of
            data store changes, median values, ranges and rates of the
            changes, results of configured function calls and expressions,
            etc. - in short, any data the client may find interesting about
            the associated event with all the logic to compute said data
            delegated to the server. Importantly, ECA notifications are the
            only ECA actions that directly interact with and hence need to be
            unambiguously understood by the client. Furthermore, the same ECA
            may originate numerous single or repetitive semantically different
            notifications within the same or separate event firings. In order
            to facilitate for the client the correlation of events and ECA
            notifications received from the server, the ECA model requires
            each notification to carry mandatory information, such as event
            and (event scope unique) notification names.</t>

            <t>Multiple ECA Actions could be triggered by a single ECA
            event.</t>

            <t>Any given ECA Condition or Action may appear in more than one
            ECAs.</t>
          </list></t>

        <t>The model structure for the actions is shown below: <figure>
            <artwork>     +--rw actions
     |  +--rw action* [name]
     |     +--rw name                   string
     |     +--rw action-element* [name]
     |     |  +--rw name                      string
     |     |  +--rw action-type?              identityref
     |     |  +--rw (action-operation)?
     |     |     +--:(notify-operation)
     |     |        +--rw notify-operation
     |     |           +--rw name?              string
     |     |           +--rw policy-variable* [name]
     |     |              +--rw name    string
     |     +--rw time-schedule!
     |     |  +--rw period?   centiseconds
     |     |  +--rw count?    uint16</artwork>
          </figure></t>
      </section>

      <section title="ECA">
        <t>An ECA container includes:<list style="symbols">
            <t>ECA name.</t>

            <t>List of local PVs and global PVs. As mentioned, These PVs could
            be configured as dynamic (their instances appear/disappear with
            start/stop of the ECA execution) or as static (their instances
            exist as long as the ECA is configured). Global PV will be shared
            by multiple ECA instances while local PVs are within the scope of
            a specific ECA instance.</t>

            <t>Normal CONDITION-ACTION list: configured conditions each with
            associated actions to be executed if the condition is evaluated to
            TRUE</t>
          </list></t>

        <t>TBD: how different ECAs do not impact each other if they share PVs
        and other components is not in the scope of this document at this
        moment.</t>

        <section anchor="ecalib" title="ECA XPath Function Library (ECALIB)">
          <t>A set of common event PVs need to be set for every invocation of
          condition or action logic:</t>

          <figure>
            <artwork>   $event-type      (string)
   $event-name    (string)

For event-type = "server-event"

  $event-stream   (string)
  $event-module   (string)
  $event-name     (string)
  $event          (node-set)

The condition can use these PVs directly in an expression
An expression can access client-configured PVs of course

   $event/child[name=$some-global-var] &gt; 10

For event-type = "datastore"

  $datastore  (string)
  $data-path  (string)
  $data       (node-set)
 
The data is defined to be a container with the requested data as child nodes

  $data/interface[type=$gigabit-eth] // (node-set is an array of data nodes, usually siblings)

A standard sustained-event func call should be defined to specify how many seconds the
 XPath expression needs to be true to consider the function result true
    
// check every 5 seconds up to 60 seconds
  sustained-event("$event/child[name=$some-global-var] &gt; 10", 5, 12)

function boolean sustained-event (string expr, number interval, number count)
        test expression 'expr' once per 'interval'. Keep testing once per interval until
        false result reached or 'count' number of interval on specific interface has been 
        tested true.Return true if condition tested true for count intervals; Returns 
        false otherwise</artwork>
          </figure>

          <t>The ECA XPath function library is expected to grow over time and
          additional standard or vendor function libraries should be possible.
          The server should provide a read-only list of ECA function libraries
          supported.<figure>
              <artwork>
     +--rw eca-func-libs
        +--rw eca-function* [func-name]
           +--rw func-name    string
           +--rw eca* [eca-name]
              +--rw eca-name    -&gt; /gncd/ecas/eca/name</artwork>
            </figure></t>

          <t>TBD: How can ECA access specific datastores? Currently no NMDA
          support for config=true values in &lt;operational&gt; is provided.
          Access to &lt;candidate&gt; datastore is not possible.</t>
        </section>
      </section>
    </section>

    <section title="ECA YANG Model (Tree Structure)">
      <t>The following tree diagrams [RFC8340] provide an overview of the data
      model for the "ietf-eca" module. <figure>
          <artwork>module: ietf-eca
  +--rw gncd
     +--rw policy-variables
     |  +--rw policy-variable* [name]
     |     +--rw name                            string
     |     +--rw (xpath-value-choice)?
     |        +--:(policy-source)
     |        |  +--rw (pv-source)
     |        |     +--:(xpath-expr)
     |        |     |  +--rw xpath-expr?         yang:xpath1.0
     |        |     +--:(scalar-constant)
     |        |     |  +--rw scalar-constant?    string
     |        |     +--:(nodeset-constant)
     |        |        +--rw nodeset-constant?   &lt;anydata&gt;
     |        +--:(policy-result)
     |           +--rw (pv-result)
     |              +--:(scalar-value)
     |              |  +--rw scalar-value?       string
     |              +--:(nodeset-value)
     |                 +--rw nodeset-value?      &lt;anydata&gt;
     +--rw events
     |  +--rw event* [event-name]
     |     +--rw event-name               string
     |     +--rw event-type?              identityref
     |     +--rw policy-variable*         -&gt; /gncd/policy-variables/policy-variable/name
     |     +--rw local-policy-variable*   -&gt; /gncd/ecas/eca/policy-variable/name
     |     +--rw (type-choice)?
     |        +--:(server-event)
     |        |  +--rw event-stream?      string
     |        |  +--rw event-module?      string
     |        |  +--rw event?             &lt;anydata&gt;
     |        +--:(datastore-event)
     |        |  +--rw datatore?          string
     |        |  +--rw data-path?         string
     |        |  +--rw data?              &lt;anydata&gt;
     |        +--:(timer-event)
     |        |  +--rw time-schedule!
     |        |     +--rw period?   centiseconds
     |        |     +--rw count?    uint16
     |        +--:(diagnostics-event)
     +--rw conditions
     |  +--rw condition* [name]
     |     +--rw name                     string
     |     +--rw (expression-choice)?
     |        +--:(xpath)
     |           +--rw condition-xpath?   string
     +--rw actions
     |  +--rw action* [name]
     |     +--rw name              string
     |     +--rw action-element* [name]
     |     |  +--rw name                      string
     |     |  +--rw action-type?              identityref
     |     |  +--rw (action-operation)?
     |     |     +--:(notify-operation)
     |     |        +--rw notify-operation
     |     |           +--rw name?              string
     |     |           +--rw policy-variable* [name]
     |     |              +--rw name    string
     |     +--rw time-schedule!
     |        +--rw period?   centiseconds
     |        +--rw count?    uint16
     +--rw ecas
     |  +--rw eca* [name]
     |     +--rw name                string
     |     +--rw username            string
     |     +--rw event-name          string
     |     +--rw policy-variable* [name]
     |     |  +--rw name                            string
     |     |  +--rw (xpath-value-choice)?
     |     |  |  +--:(policy-source)
     |     |  |  |  +--rw (pv-source)
     |     |  |  |     +--:(xpath-expr)
     |     |  |  |     |  +--rw xpath-expr?         yang:xpath1.0
     |     |  |  |     +--:(scalar-constant)
     |     |  |  |     |  +--rw scalar-constant?    string
     |     |  |  |     +--:(nodeset-constant)
     |     |  |  |        +--rw nodeset-constant?   &lt;anydata&gt;
     |     |  |  +--:(policy-result)
     |     |  |     +--rw (pv-result)
     |     |  |        +--:(scalar-value)
     |     |  |        |  +--rw scalar-value?       string
     |     |  |        +--:(nodeset-value)
     |     |  |           +--rw nodeset-value?      &lt;anydata&gt;
     |     |  +--rw is-static?                      boolean
     |     +--rw condition-action* [name]
     |     |  +--rw name         string
     |     |  +--rw condition?   -&gt; /gncd/conditions/condition/name
     |     |  +--rw action?      -&gt; /gncd/actions/action/name
     |     +---x start
     |     +---x stop
     |     +---x next-action
     +--rw eca-func-libs
        +--rw eca-function* [func-name]
           +--rw func-name    string
           +--rw eca* [eca-name]
              +--rw eca-name    -&gt; /gncd/ecas/eca/name

  notifications:
    +---n eca-exception
       +--ro reason?   identityref
</artwork>
        </figure></t>
    </section>

    <section title="ECA YANG Module">
      <t>&lt;CODE BEGINS&gt; file "ietf-eca@2019-10-28.yang"</t>

      <figure>
        <artwork>module ietf-eca {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-eca";
  prefix gnca;

  import ietf-yang-types {
    prefix yang;
  }
  import ietf-netconf-acm {
    prefix nacm;
    reference
      "RFC8341: Network Configuration Access Control Model";
  }

  organization
    "IETF Network Configuration (NETCONF) Working Group";
  contact
    "WG Web:   &lt;http://tools.ietf.org/wg/netmod/&gt;
     WG List:  &lt;mailto:netmod@ietf.org&gt;
     Editor:   Qin Wu
               &lt;mailto:bill.wu@huawei.com&gt;
     Editor:   Igor Bryskin
               &lt;mailto:Igor.Bryskin@huawei.com&gt;
     Editor:   Henk Birkholz
               &lt;mailto:henk.birkholz@sit.fraunhofer.de&gt;
     Editor:   Xufeng Liu
               &lt;mailto:xufeng.liu.ietf@gmail.com&gt;
     Editor:   Benoit Claise
               &lt;mailto:bclaise@cisco.com&gt;
     Editor:   Andy Bierman
               &lt;mailto:andy@yumaworks.com&gt;
     Editor:   Alexander Clemm
               &lt;mailto:ludwig@clemm.org&gt;";
  description
    "Event Condition Action (ECA) model.";

  revision 2018-06-22 {
    description
      "Initial revision";
    reference
      "RFC XXXX";
  }

  identity argument-type {
    description
      "Possible values are:
       constant, variable, or datastore state.";
  }

  identity comparison-type {
    description
      "Possible values are:
       equal, not-equal, greater, greater-equal, less, less-equal.";
  }

  identity logical-operation-type {
    description
      "Possible values are:
       not, or, and.";
  }

  identity function-type {
    description
      "Possible values are:
       plus, minus, mult, divide, sustained-event.";
  }

  identity sustained-event {
    description
      "Identity for standard sustained-event function call,
       the input variables for sustained-event include string
       expr, number interval, number count. Keep testing
       expression 'expr'once per interval until false result
       reached or 'count' number of interval on specific interface
       has been tested true.Return true if condition tested true
       for count intervals; Returns false otherwise.";
  }

  identity plus {
    description
      "Identity for standard plus function call, the input
       variables for plus function call include src policy argument
       and dst policy arugment.";
  }

  identity mius {
    description
      "Identity for standard minus function call, the input
       variables for plus function call include src policy argument
       and dst policy arugment.";
  }

  identity multiply {
    description
      "Identity for standard multiply function call, the input
       variables for multiply function call include src policy argument
       and dst policy arugment.";
  }

  identity divide {
    description
      "Identity for standard divide function call, the input
       variables for multiply function call include src policy argument
       and dst policy arugment.";
  }

  identity content-moving-operation-type {
    description
      "Possible values are:
       copy, iterate, insert.";
  }

  identity action-type {
    description
      "Possible values are:
       action, content-move, function-call, rpc, notify.";
  }

  identity policy-variable-type {
    description
      "Possible values are:
       boolean, int32, int64, uint32, uint64, string, etc.";
  }

  identity event-type {
    description
      "Base identity for Event Type.";
  }

  identity server-event {
    base event-type;
    description
      "Identity for server event.";
  }

  identity datastore-event {
    base event-type;
    description
      "Identity for datastore event.";
  }

  identity timer-event {
    base event-type;
    description
      "Identity for timer event.";
  }

  identity diagnostics-event {
    base event-type;
    description
      "Identity for diagnostics event.";
  }

  identity eca-exception-reason {
    description
      "Base of all values for the 'reason' leaf in the
       eca-exception notification.";
  }

  identity varbind-unknown {
    base eca-exception-reason;
    description
      "The requested policy variable binding is not defined.
       The variable binding cannot be resolved in the XPath
       evaluation.";
  }

  typedef centiseconds {
    type uint32;
    description
      "A period of time, measured in units of 0.01 seconds.";
  }

  typedef oper-status {
    type enumeration {
      enum completed {
        description
          "Completed with no error.";
      }
      enum running {
        description
          "Currently with no error.";
      }
      enum sleeping {
        description
          "Sleeping because of time schedule.";
      }
      enum stoped {
        description
          "Stopped by the operator.";
      }
      enum failed {
        description
          "Failed with errors.";
      }
      enum error-handling {
        description
          "Asking the operator to handle an error.";
      }
    }
    description
      "The operational status of an ECA execution.";
  }

  grouping scalar-value {
    leaf scalar-value {
      type string;
      description
        "Represents an XPath simple value that has an
         XPath type of Boolean, String, or Number.
         This value will be converted to an XPath type,
         as needed.

         A YANG value is encoded as a string using the same
         rules as the 'default' value for the data type.

         An eca-exception notification is generated if a scalar
         XPath value is used in a path expression, where a
         node-set is expected. Normally XPath will treat this result
         as an empty node-set, but this is an ECA programming error.";
    }
  }

  grouping nodeset-value {
    anydata nodeset-value {
      description
        "Represents an XPath node set. A 'node-set' anydata node
         with no child data nodes represents an empty node-set.
         Each child node in within this anydata structure
         represents a subtree that is present in the XPath
         node-set.

         An XPath node-set is not required to contain a top-level
         YANG data node.  It is not required to contain an entire
         complete subtree.

         It is am implementation-specific manner how a
         representation of YANG 'anydata' nodes are mapped
         to specific YANG module schema definitions.";
    }
  }

  grouping scalar-constant {
    leaf scalar-constant {
      type string;
      description
        "Represents an XPath simple value that has an
         XPath type of Boolean, String, or Number.
         This value will be converted to an XPath type,
         as needed.

         A YANG value is encoded as a string using the same
         rules as the 'default' value for the data type.

         An eca-exception notification is generated if a scalar
         XPath value is used in a path expression, where a
         node-set is expected. Normally XPath will treat this result
         as an empty node-set, but this is an ECA programming error.";
    }
  }

  grouping nodeset-constant {
    anydata nodeset-constant {
      description
        "Represents an XPath node set. A 'node-set' anydata node
         with no child data nodes represents an empty node-set.
         Each child node in within this anydata structure
         represents a subtree that is present in the XPath
         node-set.

         An XPath node-set is not required to contain a top-level
         YANG data node.  It is not required to contain an entire
         complete subtree.

         It is am implementation-specific manner how a
         representation of YANG 'anydata' nodes are mapped
         to specific YANG module schema definitions.";
    }
  }

  grouping pv-source {
    choice pv-source {
      mandatory true;
      description
        "A PV source represents an XPath result, which contains
         one of four data types: Boolean, Number, String,
         and Node Set.  XPath defines mechanisms to covert
         values between these four types.

         The 'xpath-expr' leaf is used to assign the PV source
         to the result of an arbitrary XPath expression.
         The result of this expression evaluation is used
         internally as needed. The result may be any one of
         the XPath data types.

         The 'scalar-constant' leaf is used to represent a Boolean,
         String, or Number XPath constant value.

         The 'nodeset-constant' anydata structure is used to
         represent a constant XPath node-set.";
      leaf xpath-expr {
        type yang:xpath1.0;
        description
          "Contains an XPath expression that must be evaluated
           to produce an XPath value. [section X.X] describes
           the XPath execution environment used to process this
           object.";
      }
      case scalar-constant {
        uses scalar-constant;
      }
      case nodeset-constant {
        uses nodeset-constant;
      }
    }
  }

  grouping pv-result {
    choice pv-result {
      mandatory true;
      description
        "Represents the value of the result of an
         Policy Variable evaluation.

         The 'scalar-value' leaf is used to represent a Boolean,
         String, or Number XPath result value.

         The 'nodeset-value' anydata structure is used to represent
         an XPath node-set result.";
      case scalar-value {
        uses scalar-value;
      }
      case nodeset-value {
        uses nodeset-value;
      }
    }
  }

  grouping policy-variable-attributes {
    description
      "Defining the policy variable attributes, including name, type
       and value. These attributes are used as part of the Policy
       Variable (PV) definition.";
    leaf name {
      type string;
      description
        "A string to uniquely identify a Policy Variable (PV), either
         globally for a global PV, or within the soope of ECA for a
         local PV.";
    }
    choice xpath-value-choice {
      description
        "The type of a policy variable may be either a common
         primative type like boolean or a type from existing
         schema node referenced by an XPath string.";
      case policy-source {
        uses pv-source;
      }
      case policy-result {
        uses pv-result;
      }
    }
  }

  grouping action-element-attributes {
    description
      "Grouping of action element attributes.";
    leaf action-type {
      type identityref {
        base action-type;
      }
      description
        "Identifies the action type.";
    }
    choice action-operation {
      description
        "The operation choices that an ECA Action can take.";
      case notify-operation {
        container notify-operation {
          description
            "The operation is to send a YANG notification.";
          leaf name {
            type string;
            description
              "Name of the subscribed YANG notification.";
          }
          list policy-variable {
            key "name";
            description
              "A list of policy arguments carried in the notification
               message.";
            leaf name {
              type string;
              description
                "A string name used as the list key to form a list
                 of policy arguments.";
            }
          }
        }
      }
    }
  }

  grouping time-schedule-container {
    description
      "Grouping to define a container of a time schedule.";
    container time-schedule {
      presence "Presence indicates that the timer is enabled.";
      description
        "Specifying the time schedule to execute an ECA Action, or
         trigger an event.";
      leaf period {
        type centiseconds;
        description
          "Duration of time that should occur between periodic
           push updates, in units of 0.01 seconds.";
      }
      leaf count {
        type uint16;
        description
          "specify the count number of interval that has to pass before
           successive adaptive periodic push update records for the same
           subscription are generated for a receiver.";
      }
    }
  }

  container gncd {
    nacm:default-deny-all;
    description
      "Top level container for Generalized Network Control Automation
       (gncd).";
    container policy-variables {
      description
        "Container of global Policy Variables (PVs).";
      list policy-variable {
        key "name";
        description
          "A list of global Policy Variables (PVs), with a string
           name as the entry key.";
        uses policy-variable-attributes;
      }
    }
    container events {
      description
        "Container of ECA events.";
      list event {
        key "event-name";
        description
          "A list of events used as the triggers of ECAs.";
        leaf event-name {
          type string;
          description
            "The name of the event.";
        }
        leaf event-type {
          type identityref {
            base event-type;
          }
          description
            "The type of the event.";
        }
        leaf-list policy-variable {
          type leafref {
            path "/gncd/policy-variables/policy-variable/name";
          }
          description
            "global policy variables, which
             are shared by all ECA scripts.";
        }
        leaf-list local-policy-variable {
          type leafref {
            path "/gncd/ecas/eca/policy-variable/name";
          }
          description
            "local policy variables, which
             are kept within an ECA instance, and appears/
             disappears with start/stop of the ECA execution.";
        }
        choice type-choice {
          description
            "The type of an event, including server event and datastore event.";
          case server-event {
            leaf event-stream {
              type string;
              description
                "The name of a subscribed stream .";
            }
            leaf event-module {
              type string;
              description
                "The name of YANG data module associated with the subscribed
                 stream.";
            }
            anydata event {
              description
                "This anydata value MUST Contain the absolute XPath
                 expression identifying the element path to the node that is
                 associated with subscribed stream.";
            }
          }
          case datastore-event {
            leaf datatore {
              type string;
              description
                "The name of a datatore from which applications
                 subscribe to updates.";
            }
            leaf data-path {
              type string;
              description
                "The absolute XPath expression identifying the
                 element path to the node that is associated with
                 subscribed stream..";
            }
            anydata data {
              description
                "This anydata value MUST Contain the node that is
                            associated with the data path.";
            }
          }
          case timer-event {
            uses time-schedule-container {
              description
                "Specifying the time schedule to trigger the event.
                 If not specified, the event is not triggered.";
            }
          }
          case diagnostics-event;
        }
      }
    }
    container conditions {
      description
        "Container of ECA Conditions.";
      list condition {
        key "name";
        description
          "A list of ECA Conditions.";
        leaf name {
          type string;
          description
            "A string name to uniquely identify an ECA Condition
             globally.";
        }
        choice expression-choice {
          description
            "The choices of expression format to specify a condition,
             which can be either a XPath string.";
          case xpath {
            leaf condition-xpath {
              type string;
              description
                "A XPath string, representing a logical expression,
                 which can contain comparisons of datastore values
                 and logical operations in the XPath format.";
            }
          }
        }
      }
    }
    container actions {
      description
        "Container of ECA Actions.";
      list action {
        key "name";
        description
          "A list of ECA Actions.";
        leaf name {
          type string;
          description
            "A string name to uniquely identify an ECA Action
             globally.";
        }
        list action-element {
          key "name";
          description
            "A list of elements contained in an ECA Action. ";
          leaf name {
            type string;
            description
              "A string name to uniquely identify the action element
               within the scope of an ECA action.";
          }
          uses action-element-attributes;
        }
        uses time-schedule-container {
          description
            "Specifying the time schedule to execute this ECA
             Action.
             If not specified, the ECA Action is executed immediately
             when it is called.";
        }
      }
    }
    container ecas {
      description
        "Container of ECAs.";
      list eca {
        key "name";
        description
          "A list of ECAs";
        leaf name {
          type string;
          description
            "A string name to uniquely identify an ECA globally.";
        }
        leaf username {
          type string;
          mandatory true;
          description
            "Name of the user for the session.";
        }
        leaf event-name {
          type string;
          mandatory true;
          description
            "The name of an event that triggers the execution of
             this ECA.";
        }
        list policy-variable {
          key "name";
          description
            "A list of ECA local Policy Variables (PVs), with a
             string name as the entry key.";
          uses policy-variable-attributes;
          leaf is-static {
            type boolean;
            description
              "'true' if the PV is static; 'false' if the PV is
               dynamic.
               A dynamic PV appears/disappears with the start/stop
               of the ECA execution; a static PV exists as long as
               the ECA is configured.";
          }
        }
        list condition-action {
          key "name";
          ordered-by user;
          description
            "A list of Condition-Actions, which are configured
             conditions each with associated actions to be executed
             if the condition is evaluated to TRUE.
             [TBD Does the server do all the actions where the condition 
             is true? Does it stop after one condition-action is completed?
             How is it possible to require multiple conditions to be true
             in order to do 1 action? How will conditions be reusable
             and not giant cut-and-paste combination of other entries?]";
          leaf name {
            type string;
            description
              "A string name uniquely identify a Condition-Action
               within this ECA.";
          }
          leaf condition {
            type leafref {
              path "/gncd/conditions/condition/name";
            }
            description
              "The reference to a configured condition.";
          }
          leaf action {
            type leafref {
              path "/gncd/actions/action/name";
            }
            description
              "The reference to a configured action.";
          }
        }
        action start {
          description
            "Start to execute this ECA.";
        }
        action stop {
          description
            "Stop the execution of this ECA.";
        }
        action next-action {
          description
            "Resume the execution of this ECA to complete the next
             action.";
        }
      }
    }
    container eca-func-libs {
      description
        "Container of ECA Function Libraries.";
      list eca-function {
        key "func-name";
        description
          "A list of ECA standard function.";
        leaf func-name {
          type string;
          description
            "A string name to uniquely identify an ECA standard function.";
        }
        list eca {
          key "eca-name";
          description
            "A list of ECAs contained in this ECA function libraries.";
          leaf eca-name {
            type leafref {
              path "/gncd/ecas/eca/name";
            }
            description
              "The reference to a configured ECA.";
          }
        }
      }
    }
  }

  notification eca-exception {
    description
      "This notification is sent when some error occurs
       while the server is processing ECA logic.
       [TBD: lots more detail and parameters]";
    leaf reason {
      type identityref {
        base eca-exception-reason;
      }
    }
  }
}</artwork>
      </figure>

      <t>&lt;CODE ENDS&gt;</t>
    </section>

    <section title="Security Considerations">
      <t>The YANG modules defined in this document MAY be accessed via the
      RESTCONF protocol [RFC8040] or NETCONF protocol ([RFC6241]). The lowest
      RESTCONF or NETCONF layer requires that the transport-layer protocol
      provides both data integrity and confidentiality, see Section 2 in
      [RFC8040] and [RFC6241]. The lowest NETCONF layer is the secure
      transport layer, and the mandatory-to-implement secure transport is
      Secure Shell (SSH)[RFC6242] . The lowest RESTCONF layer is HTTPS, and
      the mandatory-to-implement secure transport is TLS [RFC5246].</t>

      <t>The NETCONF access control model [RFC6536] provides the means to
      restrict access for particular NETCONF or RESTCONF users to a
      preconfigured subset of all available NETCONF or RESTCONF protocol
      operations and content.</t>

      <t>There are a number of data nodes defined in this YANG module that are
      writable/creatable/deletable (i.e., config true, which is the default).
      These data nodes may be considered sensitive or vulnerable in some
      network environments. Write operations (e.g., edit-config) to these data
      nodes without proper protection can have a negative effect on network
      operations. These are the subtrees and data nodes and their
      sensitivity/vulnerability: <list style="symbols">
          <t>/gnca:gncd/gnca:policy-variables/gnca:policy-variable/gnca:name</t>

          <t>/gnca:gncd/gnca:events/gnca:event/gnca:name</t>

          <t>/gnca:gncd/gnca:conditions/gnca:condition/gnca:name</t>

          <t>/gnca:gncd/gnca:actions/gnca:action/gnca:name</t>

          <t>/gnca:gncd/gnca:ecas/gnca:eca/gnca:name</t>

          <t>/gnca:gncd/gnca:ecas/gnca:eca/gnca:username</t>

          <t>/gnca:gncd/gnca:eca-func-libs/gnca:eca-function/gnca:func-name</t>
        </list></t>
    </section>

    <section title="IANA Considerations">
      <t>This document registers two URIs in the IETF XML registry <xref
      target="RFC3688"/>. Following the format in <xref target="RFC3688"/>,
      the following registrations are requested to be made:</t>

      <figure>
        <artwork>---------------------------------------------------------------------
   URI: urn:ietf:params:xml:ns:yang:ietf-eca
   Registrant Contact: The IESG.
   XML: N/A, the requested URI is an XML namespace.
---------------------------------------------------------------------</artwork>
      </figure>

      <t>This document registers one YANG module in the YANG Module Names
      registry <xref target="RFC6020"/>.</t>

      <figure>
        <artwork>---------------------------------------------------------------------
   Name:         ietf-eca
   Namespace:    urn:ietf:params:xml:ns:yang:ietf-eca
   Prefix:       gnca
   Reference:    RFC xxxx
---------------------------------------------------------------------</artwork>
      </figure>
    </section>

    <section title="Acknowledges">
      <t>Igor Bryskin, Xufeng Liu, Alexander Clemm, Henk Birkholz, Tianran
      Zhou contributed to an earlier version of [GNCA]. We would like to thank
      the authors of that document on event response behaviors delegation for
      material that assisted in thinking that helped improve this
      document.</t>
    </section>

    <section title="Contributors">
      <figure>
        <artwork>   Alexander Clemm
   Futurewei
   Email: ludwig@clemm.org

   Michale Wang
   Huawei
   Email:wangzitao@huawei.com

   Chongfeng Xie
   China Telecom
   Email: xiechf@ctbri.com.cn

   Xiaopeng Qin
   Huawei
   Huawei Bld., No.156 Beiqing Rd.
   Beijing  100095
   China
   qinxiaopeng@huawei.com

   Tianran Zhou
   Huawei
   Email: zhoutianran@huawei.com

   Aihua Guo
   Individual
   aihguo1@gmail.com

   Nicola Sambo
   Scuola Superiore Sant'Anna
   Via Moruzzi 1
   Pisa  56124
   Italy
   Email: nicola.sambo@sssup.it

   Giuseppe Fioccola
   Huawei Technologies
   Riesstrasse, 25
   Munich  80992
   Germany
   Email: giuseppe.fioccola@huawei.com</artwork>
      </figure>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate
          Requirement Levels</title>

          <author fullname="Scott Bradner" initials="S." surname="Bradner">
            <organization>Harvard University</organization>

            <address>
              <postal>
                <street>1350 Mass. Ave.</street>

                <street>Cambridge</street>

                <street>MA 02138</street>
              </postal>

              <phone>+1 617 495 3864</phone>

              <email>sob@harvard.edu</email>
            </address>
          </author>

          <date month="March" year="1997"/>

          <area>General</area>

          <keyword>keyword</keyword>

          <abstract>
            <t>In many standards track documents several words are used to
            signify the requirements in the specification. These words are
            often capitalized. This document defines these words as they
            should be interpreted in IETF documents. Authors who follow these
            guidelines should incorporate this phrase near the beginning of
            their document: <list>
                <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
                "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
                "OPTIONAL" in this document are to be interpreted as described
                in RFC 2119.</t>
              </list></t>

            <t>Note that the force of these words is modified by the
            requirement level of the document in which they are used.</t>
          </abstract>
        </front>
      </reference>

      <?rfc include="reference.RFC.7950.xml"?>

      <?rfc include="reference.RFC.3688.xml"?>

      <?rfc include="reference.RFC.6020.xml"?>

      <?rfc include="reference.RFC.6241.xml"?>

      <?rfc include="reference.RFC.6242.xml"?>

      <?rfc include="reference.RFC.6536.xml"?>

      <?rfc include="reference.RFC.3460.xml"?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.RFC.5246.xml"?>

      <?rfc include="reference.RFC.8340.xml"?>

      <?rfc include="reference.RFC.8342.xml"?>

      <?rfc include="reference.RFC.8040.xml"?>
    </references>

    <section title="ECA Condition Expression Examples">
      <t>Here are two examples of Condition Expression:</t>

      <t>(a) a condition that only includes data store states and constants,
      for example: <figure>
          <artwork>TE metric of Link L in Topology T  greater than 100, 
it can be expressed as follows:

 "/nw:networks/nw:network[network-id='T']/nt:link[link-id='L']/tet:te\
 /tet:te-link-attributes/tet:te-delay-metric &gt; 100"</artwork>
        </figure></t>

      <t>(b) a condition that also includes a Policy Variable, for
      example:<figure>
          <artwork>Allocated bandwidth of Link L in Topology T greater than 75% of 
what is stored in Policy Variable B, it can be expressed as follows:

"/nw:networks/nw:network[network-id='T']/nt:link[link-id='L']/tet:te\
 /tet:te-link-attributes/tet:max-resv-link-bandwidth\
 &gt; (ietf-eca:policy-variables/policy-variable[name='B']/value) * 0.75" </artwork>
        </figure></t>
    </section>

    <section title="ECA Model Self Monitoring Usage Example">
      <figure>
        <artwork>  +---------------------------+
  |     Management System     |
  +---------------------------+
            |           
        ECA |           
      Model |           
            |           
            V           
 +----------------------^-----+
 |      Managed Device  |     |
 |                      |     |
 |    //--\\ Condition--+     |
 |   | Event|       /    \    |
 |   |      |-----&gt;|Actions   |
 |    \\--//        \    /    |
 |                   ----     |
 +----------------------------+ </artwork>
      </figure>

      <t>The management system designs a new ECA policy based on monitored
      objects in ietf-interfaces module that support threshold checking and
      pushes down the ECA policy to control interface behavior in the managed
      device that supports NETCONF/RESTCONF protocol operation, i.e.,scan all
      interfaces for a certain type every 5 seconds up to 60 seconds and check
      the counters or status, return an array of interface entries (XPath
      node-set) that match the search. The XML example snippet is shown as
      below:</t>

      <figure>
        <artwork>&lt;gnca&gt;
 &lt;policy-variables&gt;
  &lt;policy-variable&gt;
    &lt;name&gt;event-name&lt;/name&gt;
    &lt;scalar-constant&gt;interface-self-monitoring&lt;/scalar-constant&gt;
  &lt;/policy-variable&gt;
  &lt;policy-variable&gt;
    &lt;name&gt;event-type&lt;/name&gt;
    &lt;scalar-constant&gt;server-event&lt;/scalar-constant&gt;
  &lt;/policy-variable&gt;
  &lt;policy-variable&gt;
    &lt;name&gt;event-stream&lt;/name&gt;
    &lt;scalar-constant&gt;NETCONF&lt;/scalar-constant&gt;
  &lt;/policy-variable&gt;
  &lt;policy-variable&gt;
    &lt;name&gt;event-module&lt;/name&gt;
    &lt;scalar-constant&gt;ietf-interfacs&lt;/scalar-constant&gt;
  &lt;/policy-variable&gt;
  &lt;policy-variable&gt;
    &lt;name&gt;event&lt;/name&gt;
    &lt;xpath-expr&gt;if:interfaces/if:interface[if:type=if:gigabitEthernet]&lt;/xpath-expr&gt;
  &lt;/policy-variable&gt;
 &lt;/policy-variables&gt;
 &lt;events&gt;
    &lt;event&gt;
     &lt;event-name&gt;interface-self-monitoring&lt;/name&gt;
     &lt;event-type&gt;server-event&lt;/event-type&gt;
     &lt;event-stream&gt;NETCONF&lt;/event-stream&gt;
     &lt;event-module&gt;ietf-interfacs&lt;/event-module&gt;
     &lt;event&gt;if:interfaces/if:interface[if:type=if:gigabitEthernet]&lt;/event&gt;
   &lt;/event&gt;
 &lt;/events&gt;
 &lt;conditions&gt;
  &lt;condition&gt;
    &lt;name&gt;if-monitoring-condition&lt;/name&gt;
    &lt;condition-xpath&gt;event/statistics/in-errors &gt; 1000 &lt;/condition-xpath&gt;
  &lt;/condition&gt;
 &lt;/conditions&gt;
 &lt;actions&gt;
  &lt;action&gt;
    &lt;name&gt;if-matched-statistics&lt;/name&gt;
    &lt;action-element&gt;
    &lt;/action-element&gt;
    &lt;time-schedule&gt;
      &lt;period&gt;5&lt;/period&gt;
      &lt;count&gt;12&lt;/count&gt;
    &lt;/time-schedule&gt;
  &lt;/action&gt;
 &lt;/actions&gt;
 &lt;ecas&gt;
  &lt;eca&gt;
    &lt;name&gt;interface-eca-handling&lt;/name&gt;
    &lt;event-name&gt;interface-self-monitoring&lt;/event-name&gt;
    &lt;condition-action&gt;
     &lt;name&gt;sustained-event&lt;/name&gt;
     &lt;condition&gt;if-monitoring-condition&lt;/condition&gt;
     &lt;action&gt;if-matched-statistics&lt;/action&gt;
   &lt;/condition-action&gt;
 &lt;/eca&gt;
 &lt;/ecas&gt;
&lt;eca-func-libs&gt;
&lt;eca-function&gt;
&lt;func-name&gt;sustained-event&lt;/func-name&gt;
&lt;eca&gt;
&lt;eca-name&gt;interface-eca-handling&lt;/eca-name&gt;
&lt;/eca&gt;
&lt;/eca-function&gt;
&lt;/eca-func-libs&gt;
&lt;/gnca&gt;

&lt;notification xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0"&gt;
  &lt;eventTime&gt;2016-11-21T13:51:00Z&lt;/eventTime&gt;
  &lt;eca-report&gt;
          &lt;interfaces
           xmlns="urn:ietf:params:xml:ns:yang:ietf-interfaces"
           xmlns:ianaift="urn:ietf:params:xml:ns:yang:iana-if-type"&gt;
         &lt;interface&gt;
           &lt;name&gt;GE0&lt;/name&gt;
           &lt;type&gt;ianaift:gigabitEthernet&lt;/type&gt;
           &lt;enabled&gt;false&lt;/enabled&gt;
         &lt;/interface&gt;

         &lt;interface&gt;
           &lt;name&gt;GE1&lt;/name&gt;
           &lt;type&gt;ianaift:gigabitEthernet&lt;/type&gt;
           &lt;enabled&gt;true&lt;/enabled&gt;
         &lt;/interface&gt;

         &lt;interface&gt;
           &lt;name&gt;GE2&lt;/name&gt;
           &lt;type&gt;ianaift:gigabitEthernet&lt;/type&gt;
           &lt;enabled&gt;true&lt;/enabled&gt;
         &lt;/interface&gt;
  &lt;/eca-report&gt;
&lt;/notification&gt;

&lt;notification xmlns="urn:ietf:params:xml:ns:netconf:notification:1.0"&gt;
  &lt;eventTime&gt;2016-11-21T13:53:00Z&lt;/eventTime&gt;
  &lt;eca-execution&gt;
  &lt;oper-status&gt;completed&lt;/oper-status&gt;
     &lt;event-name&gt;interface-self-monitoring&lt;/name&gt;
     &lt;event-type&gt;server-event&lt;/event-type&gt;
     &lt;event-stream&gt;NETCONF&lt;/event-stream&gt;
     &lt;event-module&gt;ietf-interfacs&lt;/event-module&gt;
     &lt;period&gt;5&lt;/period&gt;
     &lt;count&gt;12&lt;/count&gt;
  &lt;/eca-execution&gt;
&lt;/notification&gt;</artwork>
      </figure>

      <t>In this example, the event name is set to
      'interface-self-monitoring', the event type is set to 'server-event',
      the function name of ECA function libraries is set to 'sustained-event',
      the name of 'condition-action' is corresponding to standard function
      call 'sustained-event'.</t>
    </section>

    <section title="Changes between Revisions">
      <t>v08 - v09<list style="symbols">
          <t>Add ECA function libraries list in the ECA model.</t>

          <t>Subtree and data node path fixing in the security section.</t>
        </list></t>

      <t>v07 - v08<list>
          <t>Replace ECA model usage example with self monitoring usage
          example in the appendix.</t>

          <t>Clean up references.</t>

          <t>Add a new section to discuss Mapping Policy Variables to XPath
          Variables.</t>

          <t>Add a new section to discuss ECA XPath Context.</t>

          <t>Add a new section to discuss ECA Evaluation Exceptions.</t>

          <t>Rewrite Introduction to highlight elevator pitch.</t>

          <t>Replace implicit variable and explicit variable with pv-source
          variable and pv-result variable.</t>

          <t>Take out function-call, cleanup-condition-action list, execution
          list, policy argument container, eca-script list at this moment.</t>
        </list></t>

      <t>v06 - v07<list style="symbols">
          <t>Reuse alarm notification event received on an event stream (RFC
          8639) in ECA logic;</t>

          <t>Represent ECA condition expression only in the form of Xpath
          expression;</t>

          <t>Add ECA condition expression example in the appendix;</t>

          <t>Add ECA model usage example in the appendix;</t>

          <t>Remove the section to discuss the relation with YANG push;</t>

          <t>Remove the dependency to SUPA framework draft;</t>

          <t>Remove smart filter extension example in the Appendix.</t>

          <t>Bind ECA script with condition expression in the model.</t>
        </list></t>

      <t>v05 - v06<list style="symbols">
          <t>Decouple ECA model from NETCONF protocol and make it applicable
          to other network mangement protocols.</t>

          <t>Move objective section to the last section with additional
          generic objectives.</t>
        </list></t>

      <t>v04 - v05<list style="symbols">
          <t>Harmonize with draft-bryskin and add additional attributes in the
          models (e.g., policy variable, func call enhancement, rpc
          execution);</t>

          <t>ECA conditions part harmonization;</t>

          <t>ECA Event, Condition, Action, Policy Variable and Value
          definition;</t>

          <t>Change ietf-event.yang into ietf-eca.yang and remove
          ietf-event-trigger.yang</t>
        </list></t>

      <t>v02 - v03<list style="symbols">
          <t>Usage Example Update: add an usage example to introduce how to
          reuse the ietf-event-trigger module to define the
          subscription-notification smarter filter.</t>
        </list></t>

      <t>v01 - v02<list style="symbols">
          <t>Introduce the group-id which allow group a set of events that can
          be executed together</t>

          <t>Change threshold trigger condition into variation trigger
          condition to further clarify the difference between boolean trigger
          condition and variation trigger condition.</t>

          <t>Module structure optimization.</t>

          <t>Usage Example Update.</t>
        </list></t>

      <t>v00 - v01<list style="symbols">
          <t>Separate ietf-event-trigger.yang from Event management modeland
          ietf-event.yang and make it reusable in other YANG models.</t>

          <t>Clarify the difference between boolean trigger condition and
          threshold trigger condition.</t>

          <t>Change evt-smp-min and evt-smp-max into min-data-object and
          max-data-object in the data model.</t>
        </list></t>
    </section>
  </back>
</rfc>
